// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto3

#ifndef GOOGLE_PROTOBUF_INCLUDED_gtfs_2drealtime_2eproto3
#define GOOGLE_PROTOBUF_INCLUDED_gtfs_2drealtime_2eproto3

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gtfs_2drealtime_2eproto3
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gtfs_2drealtime_2eproto3 {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gtfs_2drealtime_2eproto3;
namespace MontrealSubwayRealtimeLocation {
class Alert;
struct AlertDefaultTypeInternal;
extern AlertDefaultTypeInternal _Alert_default_instance_;
class EntitySelector;
struct EntitySelectorDefaultTypeInternal;
extern EntitySelectorDefaultTypeInternal _EntitySelector_default_instance_;
class FeedEntity;
struct FeedEntityDefaultTypeInternal;
extern FeedEntityDefaultTypeInternal _FeedEntity_default_instance_;
class FeedHeader;
struct FeedHeaderDefaultTypeInternal;
extern FeedHeaderDefaultTypeInternal _FeedHeader_default_instance_;
class FeedMessage;
struct FeedMessageDefaultTypeInternal;
extern FeedMessageDefaultTypeInternal _FeedMessage_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class TimeRange;
struct TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class TranslatedString;
struct TranslatedStringDefaultTypeInternal;
extern TranslatedStringDefaultTypeInternal _TranslatedString_default_instance_;
class TranslatedString_Translation;
struct TranslatedString_TranslationDefaultTypeInternal;
extern TranslatedString_TranslationDefaultTypeInternal _TranslatedString_Translation_default_instance_;
class TripDescriptor;
struct TripDescriptorDefaultTypeInternal;
extern TripDescriptorDefaultTypeInternal _TripDescriptor_default_instance_;
class TripUpdate;
struct TripUpdateDefaultTypeInternal;
extern TripUpdateDefaultTypeInternal _TripUpdate_default_instance_;
class TripUpdate_StopTimeEvent;
struct TripUpdate_StopTimeEventDefaultTypeInternal;
extern TripUpdate_StopTimeEventDefaultTypeInternal _TripUpdate_StopTimeEvent_default_instance_;
class TripUpdate_StopTimeUpdate;
struct TripUpdate_StopTimeUpdateDefaultTypeInternal;
extern TripUpdate_StopTimeUpdateDefaultTypeInternal _TripUpdate_StopTimeUpdate_default_instance_;
class VehicleDescriptor;
struct VehicleDescriptorDefaultTypeInternal;
extern VehicleDescriptorDefaultTypeInternal _VehicleDescriptor_default_instance_;
class VehiclePosition;
struct VehiclePositionDefaultTypeInternal;
extern VehiclePositionDefaultTypeInternal _VehiclePosition_default_instance_;
}  // namespace MontrealSubwayRealtimeLocation
PROTOBUF_NAMESPACE_OPEN
template<> ::MontrealSubwayRealtimeLocation::Alert* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::Alert>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::EntitySelector* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::EntitySelector>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::FeedEntity* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::FeedEntity>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::FeedHeader* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::FeedHeader>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::FeedMessage* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::FeedMessage>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::Position* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::Position>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::TimeRange* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TimeRange>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::TranslatedString* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TranslatedString>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::TranslatedString_Translation* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TranslatedString_Translation>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::TripDescriptor* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripDescriptor>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::TripUpdate* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripUpdate>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::VehicleDescriptor* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::VehicleDescriptor>(Arena*);
template<> ::MontrealSubwayRealtimeLocation::VehiclePosition* Arena::CreateMaybeMessage<::MontrealSubwayRealtimeLocation::VehiclePosition>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace MontrealSubwayRealtimeLocation {

enum FeedHeader_Incrementality : int {
  FeedHeader_Incrementality_FULL_DATASET = 0,
  FeedHeader_Incrementality_DIFFERENTIAL = 1,
  FeedHeader_Incrementality_FeedHeader_Incrementality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FeedHeader_Incrementality_FeedHeader_Incrementality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FeedHeader_Incrementality_IsValid(int value);
constexpr FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MIN = FeedHeader_Incrementality_FULL_DATASET;
constexpr FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MAX = FeedHeader_Incrementality_DIFFERENTIAL;
constexpr int FeedHeader_Incrementality_Incrementality_ARRAYSIZE = FeedHeader_Incrementality_Incrementality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FeedHeader_Incrementality_descriptor();
template<typename T>
inline const std::string& FeedHeader_Incrementality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FeedHeader_Incrementality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FeedHeader_Incrementality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FeedHeader_Incrementality_descriptor(), enum_t_value);
}
inline bool FeedHeader_Incrementality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeedHeader_Incrementality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FeedHeader_Incrementality>(
    FeedHeader_Incrementality_descriptor(), name, value);
}
enum TripUpdate_StopTimeUpdate_ScheduleRelationship : int {
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED = 0,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED = 1,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA = 2,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_TripUpdate_StopTimeUpdate_ScheduleRelationship_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripUpdate_StopTimeUpdate_ScheduleRelationship_TripUpdate_StopTimeUpdate_ScheduleRelationship_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(int value);
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN = TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX = TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
constexpr int TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
template<typename T>
inline const std::string& TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripUpdate_StopTimeUpdate_ScheduleRelationship>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripUpdate_StopTimeUpdate_ScheduleRelationship_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), enum_t_value);
}
inline bool TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripUpdate_StopTimeUpdate_ScheduleRelationship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TripUpdate_StopTimeUpdate_ScheduleRelationship>(
    TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), name, value);
}
enum VehiclePosition_VehicleStopStatus : int {
  VehiclePosition_VehicleStopStatus_INCOMING_AT = 0,
  VehiclePosition_VehicleStopStatus_STOPPED_AT = 1,
  VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO = 2,
  VehiclePosition_VehicleStopStatus_VehiclePosition_VehicleStopStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VehiclePosition_VehicleStopStatus_VehiclePosition_VehicleStopStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VehiclePosition_VehicleStopStatus_IsValid(int value);
constexpr VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN = VehiclePosition_VehicleStopStatus_INCOMING_AT;
constexpr VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX = VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
constexpr int VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE = VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehiclePosition_VehicleStopStatus_descriptor();
template<typename T>
inline const std::string& VehiclePosition_VehicleStopStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehiclePosition_VehicleStopStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehiclePosition_VehicleStopStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehiclePosition_VehicleStopStatus_descriptor(), enum_t_value);
}
inline bool VehiclePosition_VehicleStopStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VehiclePosition_VehicleStopStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehiclePosition_VehicleStopStatus>(
    VehiclePosition_VehicleStopStatus_descriptor(), name, value);
}
enum VehiclePosition_CongestionLevel : int {
  VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL = 0,
  VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY = 1,
  VehiclePosition_CongestionLevel_STOP_AND_GO = 2,
  VehiclePosition_CongestionLevel_CONGESTION = 3,
  VehiclePosition_CongestionLevel_SEVERE_CONGESTION = 4,
  VehiclePosition_CongestionLevel_VehiclePosition_CongestionLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VehiclePosition_CongestionLevel_VehiclePosition_CongestionLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VehiclePosition_CongestionLevel_IsValid(int value);
constexpr VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MIN = VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
constexpr VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MAX = VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
constexpr int VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE = VehiclePosition_CongestionLevel_CongestionLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehiclePosition_CongestionLevel_descriptor();
template<typename T>
inline const std::string& VehiclePosition_CongestionLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehiclePosition_CongestionLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehiclePosition_CongestionLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehiclePosition_CongestionLevel_descriptor(), enum_t_value);
}
inline bool VehiclePosition_CongestionLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VehiclePosition_CongestionLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehiclePosition_CongestionLevel>(
    VehiclePosition_CongestionLevel_descriptor(), name, value);
}
enum VehiclePosition_OccupancyStatus : int {
  VehiclePosition_OccupancyStatus_EMPTY = 0,
  VehiclePosition_OccupancyStatus_MANY_SEATS_AVAILABLE = 1,
  VehiclePosition_OccupancyStatus_FEW_SEATS_AVAILABLE = 2,
  VehiclePosition_OccupancyStatus_STANDING_ROOM_ONLY = 3,
  VehiclePosition_OccupancyStatus_CRUSHED_STANDING_ROOM_ONLY = 4,
  VehiclePosition_OccupancyStatus_FULL = 5,
  VehiclePosition_OccupancyStatus_NOT_ACCEPTING_PASSENGERS = 6,
  VehiclePosition_OccupancyStatus_VehiclePosition_OccupancyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VehiclePosition_OccupancyStatus_VehiclePosition_OccupancyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VehiclePosition_OccupancyStatus_IsValid(int value);
constexpr VehiclePosition_OccupancyStatus VehiclePosition_OccupancyStatus_OccupancyStatus_MIN = VehiclePosition_OccupancyStatus_EMPTY;
constexpr VehiclePosition_OccupancyStatus VehiclePosition_OccupancyStatus_OccupancyStatus_MAX = VehiclePosition_OccupancyStatus_NOT_ACCEPTING_PASSENGERS;
constexpr int VehiclePosition_OccupancyStatus_OccupancyStatus_ARRAYSIZE = VehiclePosition_OccupancyStatus_OccupancyStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehiclePosition_OccupancyStatus_descriptor();
template<typename T>
inline const std::string& VehiclePosition_OccupancyStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehiclePosition_OccupancyStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehiclePosition_OccupancyStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehiclePosition_OccupancyStatus_descriptor(), enum_t_value);
}
inline bool VehiclePosition_OccupancyStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VehiclePosition_OccupancyStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehiclePosition_OccupancyStatus>(
    VehiclePosition_OccupancyStatus_descriptor(), name, value);
}
enum Alert_Cause : int {
  Alert_Cause_PROTO3_DEFAULT_CAUSE = 0,
  Alert_Cause_UNKNOWN_CAUSE = 1,
  Alert_Cause_OTHER_CAUSE = 2,
  Alert_Cause_TECHNICAL_PROBLEM = 3,
  Alert_Cause_STRIKE = 4,
  Alert_Cause_DEMONSTRATION = 5,
  Alert_Cause_ACCIDENT = 6,
  Alert_Cause_HOLIDAY = 7,
  Alert_Cause_WEATHER = 8,
  Alert_Cause_MAINTENANCE = 9,
  Alert_Cause_CONSTRUCTION = 10,
  Alert_Cause_POLICE_ACTIVITY = 11,
  Alert_Cause_MEDICAL_EMERGENCY = 12,
  Alert_Cause_Alert_Cause_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Alert_Cause_Alert_Cause_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Alert_Cause_IsValid(int value);
constexpr Alert_Cause Alert_Cause_Cause_MIN = Alert_Cause_PROTO3_DEFAULT_CAUSE;
constexpr Alert_Cause Alert_Cause_Cause_MAX = Alert_Cause_MEDICAL_EMERGENCY;
constexpr int Alert_Cause_Cause_ARRAYSIZE = Alert_Cause_Cause_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alert_Cause_descriptor();
template<typename T>
inline const std::string& Alert_Cause_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Alert_Cause>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Alert_Cause_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Alert_Cause_descriptor(), enum_t_value);
}
inline bool Alert_Cause_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Alert_Cause* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alert_Cause>(
    Alert_Cause_descriptor(), name, value);
}
enum Alert_Effect : int {
  Alert_Effect_PROTO3_DEFAULT_EFFECT = 0,
  Alert_Effect_NO_SERVICE = 1,
  Alert_Effect_REDUCED_SERVICE = 2,
  Alert_Effect_SIGNIFICANT_DELAYS = 3,
  Alert_Effect_DETOUR = 4,
  Alert_Effect_ADDITIONAL_SERVICE = 5,
  Alert_Effect_MODIFIED_SERVICE = 6,
  Alert_Effect_OTHER_EFFECT = 7,
  Alert_Effect_UNKNOWN_EFFECT = 8,
  Alert_Effect_STOP_MOVED = 9,
  Alert_Effect_Alert_Effect_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Alert_Effect_Alert_Effect_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Alert_Effect_IsValid(int value);
constexpr Alert_Effect Alert_Effect_Effect_MIN = Alert_Effect_PROTO3_DEFAULT_EFFECT;
constexpr Alert_Effect Alert_Effect_Effect_MAX = Alert_Effect_STOP_MOVED;
constexpr int Alert_Effect_Effect_ARRAYSIZE = Alert_Effect_Effect_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alert_Effect_descriptor();
template<typename T>
inline const std::string& Alert_Effect_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Alert_Effect>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Alert_Effect_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Alert_Effect_descriptor(), enum_t_value);
}
inline bool Alert_Effect_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Alert_Effect* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alert_Effect>(
    Alert_Effect_descriptor(), name, value);
}
enum TripDescriptor_ScheduleRelationship : int {
  TripDescriptor_ScheduleRelationship_SCHEDULED = 0,
  TripDescriptor_ScheduleRelationship_ADDED = 1,
  TripDescriptor_ScheduleRelationship_UNSCHEDULED = 2,
  TripDescriptor_ScheduleRelationship_CANCELED = 3,
  TripDescriptor_ScheduleRelationship_TripDescriptor_ScheduleRelationship_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TripDescriptor_ScheduleRelationship_TripDescriptor_ScheduleRelationship_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TripDescriptor_ScheduleRelationship_IsValid(int value);
constexpr TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN = TripDescriptor_ScheduleRelationship_SCHEDULED;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX = TripDescriptor_ScheduleRelationship_CANCELED;
constexpr int TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TripDescriptor_ScheduleRelationship_descriptor();
template<typename T>
inline const std::string& TripDescriptor_ScheduleRelationship_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripDescriptor_ScheduleRelationship>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripDescriptor_ScheduleRelationship_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TripDescriptor_ScheduleRelationship_descriptor(), enum_t_value);
}
inline bool TripDescriptor_ScheduleRelationship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripDescriptor_ScheduleRelationship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TripDescriptor_ScheduleRelationship>(
    TripDescriptor_ScheduleRelationship_descriptor(), name, value);
}
// ===================================================================

class FeedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.FeedMessage) */ {
 public:
  inline FeedMessage() : FeedMessage(nullptr) {}
  ~FeedMessage() override;
  explicit PROTOBUF_CONSTEXPR FeedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedMessage(const FeedMessage& from);
  FeedMessage(FeedMessage&& from) noexcept
    : FeedMessage() {
    *this = ::std::move(from);
  }

  inline FeedMessage& operator=(const FeedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedMessage& operator=(FeedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedMessage* internal_default_instance() {
    return reinterpret_cast<const FeedMessage*>(
               &_FeedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FeedMessage& a, FeedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedMessage& from) {
    FeedMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.FeedMessage";
  }
  protected:
  explicit FeedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .MontrealSubwayRealtimeLocation.FeedEntity entity = 2;
  int entity_size() const;
  private:
  int _internal_entity_size() const;
  public:
  void clear_entity();
  ::MontrealSubwayRealtimeLocation::FeedEntity* mutable_entity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::FeedEntity >*
      mutable_entity();
  private:
  const ::MontrealSubwayRealtimeLocation::FeedEntity& _internal_entity(int index) const;
  ::MontrealSubwayRealtimeLocation::FeedEntity* _internal_add_entity();
  public:
  const ::MontrealSubwayRealtimeLocation::FeedEntity& entity(int index) const;
  ::MontrealSubwayRealtimeLocation::FeedEntity* add_entity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::FeedEntity >&
      entity() const;

  // .MontrealSubwayRealtimeLocation.FeedHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::MontrealSubwayRealtimeLocation::FeedHeader& header() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::FeedHeader* release_header();
  ::MontrealSubwayRealtimeLocation::FeedHeader* mutable_header();
  void set_allocated_header(::MontrealSubwayRealtimeLocation::FeedHeader* header);
  private:
  const ::MontrealSubwayRealtimeLocation::FeedHeader& _internal_header() const;
  ::MontrealSubwayRealtimeLocation::FeedHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::MontrealSubwayRealtimeLocation::FeedHeader* header);
  ::MontrealSubwayRealtimeLocation::FeedHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.FeedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::FeedEntity > entity_;
    ::MontrealSubwayRealtimeLocation::FeedHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class FeedHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.FeedHeader) */ {
 public:
  inline FeedHeader() : FeedHeader(nullptr) {}
  ~FeedHeader() override;
  explicit PROTOBUF_CONSTEXPR FeedHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedHeader(const FeedHeader& from);
  FeedHeader(FeedHeader&& from) noexcept
    : FeedHeader() {
    *this = ::std::move(from);
  }

  inline FeedHeader& operator=(const FeedHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedHeader& operator=(FeedHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedHeader* internal_default_instance() {
    return reinterpret_cast<const FeedHeader*>(
               &_FeedHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FeedHeader& a, FeedHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedHeader& from) {
    FeedHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.FeedHeader";
  }
  protected:
  explicit FeedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FeedHeader_Incrementality Incrementality;
  static constexpr Incrementality FULL_DATASET =
    FeedHeader_Incrementality_FULL_DATASET;
  static constexpr Incrementality DIFFERENTIAL =
    FeedHeader_Incrementality_DIFFERENTIAL;
  static inline bool Incrementality_IsValid(int value) {
    return FeedHeader_Incrementality_IsValid(value);
  }
  static constexpr Incrementality Incrementality_MIN =
    FeedHeader_Incrementality_Incrementality_MIN;
  static constexpr Incrementality Incrementality_MAX =
    FeedHeader_Incrementality_Incrementality_MAX;
  static constexpr int Incrementality_ARRAYSIZE =
    FeedHeader_Incrementality_Incrementality_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Incrementality_descriptor() {
    return FeedHeader_Incrementality_descriptor();
  }
  template<typename T>
  static inline const std::string& Incrementality_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Incrementality>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Incrementality_Name.");
    return FeedHeader_Incrementality_Name(enum_t_value);
  }
  static inline bool Incrementality_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Incrementality* value) {
    return FeedHeader_Incrementality_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGtfsRealtimeVersionFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kIncrementalityFieldNumber = 2,
  };
  // string gtfs_realtime_version = 1;
  void clear_gtfs_realtime_version();
  const std::string& gtfs_realtime_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gtfs_realtime_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gtfs_realtime_version();
  PROTOBUF_NODISCARD std::string* release_gtfs_realtime_version();
  void set_allocated_gtfs_realtime_version(std::string* gtfs_realtime_version);
  private:
  const std::string& _internal_gtfs_realtime_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gtfs_realtime_version(const std::string& value);
  std::string* _internal_mutable_gtfs_realtime_version();
  public:

  // uint64 timestamp = 3;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .MontrealSubwayRealtimeLocation.FeedHeader.Incrementality incrementality = 2;
  void clear_incrementality();
  ::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality incrementality() const;
  void set_incrementality(::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality value);
  private:
  ::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality _internal_incrementality() const;
  void _internal_set_incrementality(::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.FeedHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gtfs_realtime_version_;
    uint64_t timestamp_;
    int incrementality_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class FeedEntity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.FeedEntity) */ {
 public:
  inline FeedEntity() : FeedEntity(nullptr) {}
  ~FeedEntity() override;
  explicit PROTOBUF_CONSTEXPR FeedEntity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedEntity(const FeedEntity& from);
  FeedEntity(FeedEntity&& from) noexcept
    : FeedEntity() {
    *this = ::std::move(from);
  }

  inline FeedEntity& operator=(const FeedEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedEntity& operator=(FeedEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedEntity* internal_default_instance() {
    return reinterpret_cast<const FeedEntity*>(
               &_FeedEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FeedEntity& a, FeedEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedEntity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedEntity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedEntity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedEntity& from) {
    FeedEntity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedEntity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.FeedEntity";
  }
  protected:
  explicit FeedEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTripUpdateFieldNumber = 3,
    kVehicleFieldNumber = 4,
    kAlertFieldNumber = 5,
    kIsDeletedFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .MontrealSubwayRealtimeLocation.TripUpdate trip_update = 3;
  bool has_trip_update() const;
  private:
  bool _internal_has_trip_update() const;
  public:
  void clear_trip_update();
  const ::MontrealSubwayRealtimeLocation::TripUpdate& trip_update() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::TripUpdate* release_trip_update();
  ::MontrealSubwayRealtimeLocation::TripUpdate* mutable_trip_update();
  void set_allocated_trip_update(::MontrealSubwayRealtimeLocation::TripUpdate* trip_update);
  private:
  const ::MontrealSubwayRealtimeLocation::TripUpdate& _internal_trip_update() const;
  ::MontrealSubwayRealtimeLocation::TripUpdate* _internal_mutable_trip_update();
  public:
  void unsafe_arena_set_allocated_trip_update(
      ::MontrealSubwayRealtimeLocation::TripUpdate* trip_update);
  ::MontrealSubwayRealtimeLocation::TripUpdate* unsafe_arena_release_trip_update();

  // .MontrealSubwayRealtimeLocation.VehiclePosition vehicle = 4;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::MontrealSubwayRealtimeLocation::VehiclePosition& vehicle() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::VehiclePosition* release_vehicle();
  ::MontrealSubwayRealtimeLocation::VehiclePosition* mutable_vehicle();
  void set_allocated_vehicle(::MontrealSubwayRealtimeLocation::VehiclePosition* vehicle);
  private:
  const ::MontrealSubwayRealtimeLocation::VehiclePosition& _internal_vehicle() const;
  ::MontrealSubwayRealtimeLocation::VehiclePosition* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::MontrealSubwayRealtimeLocation::VehiclePosition* vehicle);
  ::MontrealSubwayRealtimeLocation::VehiclePosition* unsafe_arena_release_vehicle();

  // .MontrealSubwayRealtimeLocation.Alert alert = 5;
  bool has_alert() const;
  private:
  bool _internal_has_alert() const;
  public:
  void clear_alert();
  const ::MontrealSubwayRealtimeLocation::Alert& alert() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::Alert* release_alert();
  ::MontrealSubwayRealtimeLocation::Alert* mutable_alert();
  void set_allocated_alert(::MontrealSubwayRealtimeLocation::Alert* alert);
  private:
  const ::MontrealSubwayRealtimeLocation::Alert& _internal_alert() const;
  ::MontrealSubwayRealtimeLocation::Alert* _internal_mutable_alert();
  public:
  void unsafe_arena_set_allocated_alert(
      ::MontrealSubwayRealtimeLocation::Alert* alert);
  ::MontrealSubwayRealtimeLocation::Alert* unsafe_arena_release_alert();

  // bool is_deleted = 2;
  void clear_is_deleted();
  bool is_deleted() const;
  void set_is_deleted(bool value);
  private:
  bool _internal_is_deleted() const;
  void _internal_set_is_deleted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.FeedEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::MontrealSubwayRealtimeLocation::TripUpdate* trip_update_;
    ::MontrealSubwayRealtimeLocation::VehiclePosition* vehicle_;
    ::MontrealSubwayRealtimeLocation::Alert* alert_;
    bool is_deleted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent) */ {
 public:
  inline TripUpdate_StopTimeEvent() : TripUpdate_StopTimeEvent(nullptr) {}
  ~TripUpdate_StopTimeEvent() override;
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate_StopTimeEvent(const TripUpdate_StopTimeEvent& from);
  TripUpdate_StopTimeEvent(TripUpdate_StopTimeEvent&& from) noexcept
    : TripUpdate_StopTimeEvent() {
    *this = ::std::move(from);
  }

  inline TripUpdate_StopTimeEvent& operator=(const TripUpdate_StopTimeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeEvent& operator=(TripUpdate_StopTimeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeEvent* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeEvent*>(
               &_TripUpdate_StopTimeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TripUpdate_StopTimeEvent& a, TripUpdate_StopTimeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate_StopTimeEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate_StopTimeEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate_StopTimeEvent& from) {
    TripUpdate_StopTimeEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate_StopTimeEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent";
  }
  protected:
  explicit TripUpdate_StopTimeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 2,
    kDelayFieldNumber = 1,
    kUncertaintyFieldNumber = 3,
  };
  // int64 time = 2;
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // int32 delay = 1;
  void clear_delay();
  int32_t delay() const;
  void set_delay(int32_t value);
  private:
  int32_t _internal_delay() const;
  void _internal_set_delay(int32_t value);
  public:

  // int32 uncertainty = 3;
  void clear_uncertainty();
  int32_t uncertainty() const;
  void set_uncertainty(int32_t value);
  private:
  int32_t _internal_uncertainty() const;
  void _internal_set_uncertainty(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t time_;
    int32_t delay_;
    int32_t uncertainty_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate) */ {
 public:
  inline TripUpdate_StopTimeUpdate() : TripUpdate_StopTimeUpdate(nullptr) {}
  ~TripUpdate_StopTimeUpdate() override;
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate_StopTimeUpdate(const TripUpdate_StopTimeUpdate& from);
  TripUpdate_StopTimeUpdate(TripUpdate_StopTimeUpdate&& from) noexcept
    : TripUpdate_StopTimeUpdate() {
    *this = ::std::move(from);
  }

  inline TripUpdate_StopTimeUpdate& operator=(const TripUpdate_StopTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeUpdate& operator=(TripUpdate_StopTimeUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeUpdate* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeUpdate*>(
               &_TripUpdate_StopTimeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TripUpdate_StopTimeUpdate& a, TripUpdate_StopTimeUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate_StopTimeUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate_StopTimeUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate_StopTimeUpdate& from) {
    TripUpdate_StopTimeUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate_StopTimeUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate";
  }
  protected:
  explicit TripUpdate_StopTimeUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TripUpdate_StopTimeUpdate_ScheduleRelationship ScheduleRelationship;
  static constexpr ScheduleRelationship SCHEDULED =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
  static constexpr ScheduleRelationship SKIPPED =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED;
  static constexpr ScheduleRelationship NO_DATA =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value);
  }
  static constexpr ScheduleRelationship ScheduleRelationship_MIN =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN;
  static constexpr ScheduleRelationship ScheduleRelationship_MAX =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX;
  static constexpr int ScheduleRelationship_ARRAYSIZE =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScheduleRelationship_descriptor() {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
  }
  template<typename T>
  static inline const std::string& ScheduleRelationship_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScheduleRelationship>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScheduleRelationship_Name.");
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(enum_t_value);
  }
  static inline bool ScheduleRelationship_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScheduleRelationship* value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopIdFieldNumber = 4,
    kArrivalFieldNumber = 2,
    kDepartureFieldNumber = 3,
    kStopSequenceFieldNumber = 1,
    kScheduleRelationshipFieldNumber = 5,
  };
  // string stop_id = 4;
  void clear_stop_id();
  const std::string& stop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* stop_id);
  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(const std::string& value);
  std::string* _internal_mutable_stop_id();
  public:

  // .MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent arrival = 2;
  bool has_arrival() const;
  private:
  bool _internal_has_arrival() const;
  public:
  void clear_arrival();
  const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent& arrival() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* release_arrival();
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* mutable_arrival();
  void set_allocated_arrival(::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* arrival);
  private:
  const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent& _internal_arrival() const;
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* _internal_mutable_arrival();
  public:
  void unsafe_arena_set_allocated_arrival(
      ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* arrival);
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* unsafe_arena_release_arrival();

  // .MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent departure = 3;
  bool has_departure() const;
  private:
  bool _internal_has_departure() const;
  public:
  void clear_departure();
  const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent& departure() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* release_departure();
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* mutable_departure();
  void set_allocated_departure(::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* departure);
  private:
  const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent& _internal_departure() const;
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* _internal_mutable_departure();
  public:
  void unsafe_arena_set_allocated_departure(
      ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* departure);
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* unsafe_arena_release_departure();

  // uint32 stop_sequence = 1;
  void clear_stop_sequence();
  uint32_t stop_sequence() const;
  void set_stop_sequence(uint32_t value);
  private:
  uint32_t _internal_stop_sequence() const;
  void _internal_set_stop_sequence(uint32_t value);
  public:

  // .MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5;
  void clear_schedule_relationship();
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship value);
  private:
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship _internal_schedule_relationship() const;
  void _internal_set_schedule_relationship(::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
    ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* arrival_;
    ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* departure_;
    uint32_t stop_sequence_;
    int schedule_relationship_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class TripUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.TripUpdate) */ {
 public:
  inline TripUpdate() : TripUpdate(nullptr) {}
  ~TripUpdate() override;
  explicit PROTOBUF_CONSTEXPR TripUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate(const TripUpdate& from);
  TripUpdate(TripUpdate&& from) noexcept
    : TripUpdate() {
    *this = ::std::move(from);
  }

  inline TripUpdate& operator=(const TripUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate& operator=(TripUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate* internal_default_instance() {
    return reinterpret_cast<const TripUpdate*>(
               &_TripUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TripUpdate& a, TripUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate& from) {
    TripUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.TripUpdate";
  }
  protected:
  explicit TripUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TripUpdate_StopTimeEvent StopTimeEvent;
  typedef TripUpdate_StopTimeUpdate StopTimeUpdate;

  // accessors -------------------------------------------------------

  enum : int {
    kStopTimeUpdateFieldNumber = 2,
    kTripFieldNumber = 1,
    kVehicleFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kDelayFieldNumber = 5,
  };
  // repeated .MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate stop_time_update = 2;
  int stop_time_update_size() const;
  private:
  int _internal_stop_time_update_size() const;
  public:
  void clear_stop_time_update();
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate* mutable_stop_time_update(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate >*
      mutable_stop_time_update();
  private:
  const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate& _internal_stop_time_update(int index) const;
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate* _internal_add_stop_time_update();
  public:
  const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate& stop_time_update(int index) const;
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate* add_stop_time_update();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate >&
      stop_time_update() const;

  // .MontrealSubwayRealtimeLocation.TripDescriptor trip = 1;
  bool has_trip() const;
  private:
  bool _internal_has_trip() const;
  public:
  void clear_trip();
  const ::MontrealSubwayRealtimeLocation::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::TripDescriptor* release_trip();
  ::MontrealSubwayRealtimeLocation::TripDescriptor* mutable_trip();
  void set_allocated_trip(::MontrealSubwayRealtimeLocation::TripDescriptor* trip);
  private:
  const ::MontrealSubwayRealtimeLocation::TripDescriptor& _internal_trip() const;
  ::MontrealSubwayRealtimeLocation::TripDescriptor* _internal_mutable_trip();
  public:
  void unsafe_arena_set_allocated_trip(
      ::MontrealSubwayRealtimeLocation::TripDescriptor* trip);
  ::MontrealSubwayRealtimeLocation::TripDescriptor* unsafe_arena_release_trip();

  // .MontrealSubwayRealtimeLocation.VehicleDescriptor vehicle = 3;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::MontrealSubwayRealtimeLocation::VehicleDescriptor& vehicle() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::VehicleDescriptor* release_vehicle();
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* mutable_vehicle();
  void set_allocated_vehicle(::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle);
  private:
  const ::MontrealSubwayRealtimeLocation::VehicleDescriptor& _internal_vehicle() const;
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle);
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* unsafe_arena_release_vehicle();

  // uint64 timestamp = 4;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 delay = 5;
  void clear_delay();
  int32_t delay() const;
  void set_delay(int32_t value);
  private:
  int32_t _internal_delay() const;
  void _internal_set_delay(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.TripUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate > stop_time_update_;
    ::MontrealSubwayRealtimeLocation::TripDescriptor* trip_;
    ::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle_;
    uint64_t timestamp_;
    int32_t delay_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class VehiclePosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.VehiclePosition) */ {
 public:
  inline VehiclePosition() : VehiclePosition(nullptr) {}
  ~VehiclePosition() override;
  explicit PROTOBUF_CONSTEXPR VehiclePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehiclePosition(const VehiclePosition& from);
  VehiclePosition(VehiclePosition&& from) noexcept
    : VehiclePosition() {
    *this = ::std::move(from);
  }

  inline VehiclePosition& operator=(const VehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehiclePosition& operator=(VehiclePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehiclePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehiclePosition* internal_default_instance() {
    return reinterpret_cast<const VehiclePosition*>(
               &_VehiclePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VehiclePosition& a, VehiclePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(VehiclePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehiclePosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehiclePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehiclePosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehiclePosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehiclePosition& from) {
    VehiclePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehiclePosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.VehiclePosition";
  }
  protected:
  explicit VehiclePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehiclePosition_VehicleStopStatus VehicleStopStatus;
  static constexpr VehicleStopStatus INCOMING_AT =
    VehiclePosition_VehicleStopStatus_INCOMING_AT;
  static constexpr VehicleStopStatus STOPPED_AT =
    VehiclePosition_VehicleStopStatus_STOPPED_AT;
  static constexpr VehicleStopStatus IN_TRANSIT_TO =
    VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
  static inline bool VehicleStopStatus_IsValid(int value) {
    return VehiclePosition_VehicleStopStatus_IsValid(value);
  }
  static constexpr VehicleStopStatus VehicleStopStatus_MIN =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN;
  static constexpr VehicleStopStatus VehicleStopStatus_MAX =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX;
  static constexpr int VehicleStopStatus_ARRAYSIZE =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VehicleStopStatus_descriptor() {
    return VehiclePosition_VehicleStopStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& VehicleStopStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehicleStopStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehicleStopStatus_Name.");
    return VehiclePosition_VehicleStopStatus_Name(enum_t_value);
  }
  static inline bool VehicleStopStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VehicleStopStatus* value) {
    return VehiclePosition_VehicleStopStatus_Parse(name, value);
  }

  typedef VehiclePosition_CongestionLevel CongestionLevel;
  static constexpr CongestionLevel UNKNOWN_CONGESTION_LEVEL =
    VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
  static constexpr CongestionLevel RUNNING_SMOOTHLY =
    VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY;
  static constexpr CongestionLevel STOP_AND_GO =
    VehiclePosition_CongestionLevel_STOP_AND_GO;
  static constexpr CongestionLevel CONGESTION =
    VehiclePosition_CongestionLevel_CONGESTION;
  static constexpr CongestionLevel SEVERE_CONGESTION =
    VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
  static inline bool CongestionLevel_IsValid(int value) {
    return VehiclePosition_CongestionLevel_IsValid(value);
  }
  static constexpr CongestionLevel CongestionLevel_MIN =
    VehiclePosition_CongestionLevel_CongestionLevel_MIN;
  static constexpr CongestionLevel CongestionLevel_MAX =
    VehiclePosition_CongestionLevel_CongestionLevel_MAX;
  static constexpr int CongestionLevel_ARRAYSIZE =
    VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CongestionLevel_descriptor() {
    return VehiclePosition_CongestionLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& CongestionLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CongestionLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CongestionLevel_Name.");
    return VehiclePosition_CongestionLevel_Name(enum_t_value);
  }
  static inline bool CongestionLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CongestionLevel* value) {
    return VehiclePosition_CongestionLevel_Parse(name, value);
  }

  typedef VehiclePosition_OccupancyStatus OccupancyStatus;
  static constexpr OccupancyStatus EMPTY =
    VehiclePosition_OccupancyStatus_EMPTY;
  static constexpr OccupancyStatus MANY_SEATS_AVAILABLE =
    VehiclePosition_OccupancyStatus_MANY_SEATS_AVAILABLE;
  static constexpr OccupancyStatus FEW_SEATS_AVAILABLE =
    VehiclePosition_OccupancyStatus_FEW_SEATS_AVAILABLE;
  static constexpr OccupancyStatus STANDING_ROOM_ONLY =
    VehiclePosition_OccupancyStatus_STANDING_ROOM_ONLY;
  static constexpr OccupancyStatus CRUSHED_STANDING_ROOM_ONLY =
    VehiclePosition_OccupancyStatus_CRUSHED_STANDING_ROOM_ONLY;
  static constexpr OccupancyStatus FULL =
    VehiclePosition_OccupancyStatus_FULL;
  static constexpr OccupancyStatus NOT_ACCEPTING_PASSENGERS =
    VehiclePosition_OccupancyStatus_NOT_ACCEPTING_PASSENGERS;
  static inline bool OccupancyStatus_IsValid(int value) {
    return VehiclePosition_OccupancyStatus_IsValid(value);
  }
  static constexpr OccupancyStatus OccupancyStatus_MIN =
    VehiclePosition_OccupancyStatus_OccupancyStatus_MIN;
  static constexpr OccupancyStatus OccupancyStatus_MAX =
    VehiclePosition_OccupancyStatus_OccupancyStatus_MAX;
  static constexpr int OccupancyStatus_ARRAYSIZE =
    VehiclePosition_OccupancyStatus_OccupancyStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OccupancyStatus_descriptor() {
    return VehiclePosition_OccupancyStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& OccupancyStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OccupancyStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OccupancyStatus_Name.");
    return VehiclePosition_OccupancyStatus_Name(enum_t_value);
  }
  static inline bool OccupancyStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OccupancyStatus* value) {
    return VehiclePosition_OccupancyStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopIdFieldNumber = 7,
    kTripFieldNumber = 1,
    kPositionFieldNumber = 2,
    kVehicleFieldNumber = 8,
    kCurrentStopSequenceFieldNumber = 3,
    kCurrentStatusFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kCongestionLevelFieldNumber = 6,
    kOccupancyStatusFieldNumber = 9,
  };
  // string stop_id = 7;
  void clear_stop_id();
  const std::string& stop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* stop_id);
  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(const std::string& value);
  std::string* _internal_mutable_stop_id();
  public:

  // .MontrealSubwayRealtimeLocation.TripDescriptor trip = 1;
  bool has_trip() const;
  private:
  bool _internal_has_trip() const;
  public:
  void clear_trip();
  const ::MontrealSubwayRealtimeLocation::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::TripDescriptor* release_trip();
  ::MontrealSubwayRealtimeLocation::TripDescriptor* mutable_trip();
  void set_allocated_trip(::MontrealSubwayRealtimeLocation::TripDescriptor* trip);
  private:
  const ::MontrealSubwayRealtimeLocation::TripDescriptor& _internal_trip() const;
  ::MontrealSubwayRealtimeLocation::TripDescriptor* _internal_mutable_trip();
  public:
  void unsafe_arena_set_allocated_trip(
      ::MontrealSubwayRealtimeLocation::TripDescriptor* trip);
  ::MontrealSubwayRealtimeLocation::TripDescriptor* unsafe_arena_release_trip();

  // .MontrealSubwayRealtimeLocation.Position position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::MontrealSubwayRealtimeLocation::Position& position() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::Position* release_position();
  ::MontrealSubwayRealtimeLocation::Position* mutable_position();
  void set_allocated_position(::MontrealSubwayRealtimeLocation::Position* position);
  private:
  const ::MontrealSubwayRealtimeLocation::Position& _internal_position() const;
  ::MontrealSubwayRealtimeLocation::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::MontrealSubwayRealtimeLocation::Position* position);
  ::MontrealSubwayRealtimeLocation::Position* unsafe_arena_release_position();

  // .MontrealSubwayRealtimeLocation.VehicleDescriptor vehicle = 8;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::MontrealSubwayRealtimeLocation::VehicleDescriptor& vehicle() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::VehicleDescriptor* release_vehicle();
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* mutable_vehicle();
  void set_allocated_vehicle(::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle);
  private:
  const ::MontrealSubwayRealtimeLocation::VehicleDescriptor& _internal_vehicle() const;
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle);
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* unsafe_arena_release_vehicle();

  // uint32 current_stop_sequence = 3;
  void clear_current_stop_sequence();
  uint32_t current_stop_sequence() const;
  void set_current_stop_sequence(uint32_t value);
  private:
  uint32_t _internal_current_stop_sequence() const;
  void _internal_set_current_stop_sequence(uint32_t value);
  public:

  // .MontrealSubwayRealtimeLocation.VehiclePosition.VehicleStopStatus current_status = 4;
  void clear_current_status();
  ::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus current_status() const;
  void set_current_status(::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus value);
  private:
  ::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus _internal_current_status() const;
  void _internal_set_current_status(::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus value);
  public:

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .MontrealSubwayRealtimeLocation.VehiclePosition.CongestionLevel congestion_level = 6;
  void clear_congestion_level();
  ::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel congestion_level() const;
  void set_congestion_level(::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel value);
  private:
  ::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel _internal_congestion_level() const;
  void _internal_set_congestion_level(::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel value);
  public:

  // .MontrealSubwayRealtimeLocation.VehiclePosition.OccupancyStatus occupancy_status = 9;
  void clear_occupancy_status();
  ::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus occupancy_status() const;
  void set_occupancy_status(::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus value);
  private:
  ::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus _internal_occupancy_status() const;
  void _internal_set_occupancy_status(::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.VehiclePosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
    ::MontrealSubwayRealtimeLocation::TripDescriptor* trip_;
    ::MontrealSubwayRealtimeLocation::Position* position_;
    ::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle_;
    uint32_t current_stop_sequence_;
    int current_status_;
    uint64_t timestamp_;
    int congestion_level_;
    int occupancy_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class Alert final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.Alert) */ {
 public:
  inline Alert() : Alert(nullptr) {}
  ~Alert() override;
  explicit PROTOBUF_CONSTEXPR Alert(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Alert(const Alert& from);
  Alert(Alert&& from) noexcept
    : Alert() {
    *this = ::std::move(from);
  }

  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alert& operator=(Alert&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Alert& default_instance() {
    return *internal_default_instance();
  }
  static inline const Alert* internal_default_instance() {
    return reinterpret_cast<const Alert*>(
               &_Alert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Alert& a, Alert& b) {
    a.Swap(&b);
  }
  inline void Swap(Alert* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alert* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Alert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Alert>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Alert& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Alert& from) {
    Alert::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alert* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.Alert";
  }
  protected:
  explicit Alert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Alert_Cause Cause;
  static constexpr Cause PROTO3_DEFAULT_CAUSE =
    Alert_Cause_PROTO3_DEFAULT_CAUSE;
  static constexpr Cause UNKNOWN_CAUSE =
    Alert_Cause_UNKNOWN_CAUSE;
  static constexpr Cause OTHER_CAUSE =
    Alert_Cause_OTHER_CAUSE;
  static constexpr Cause TECHNICAL_PROBLEM =
    Alert_Cause_TECHNICAL_PROBLEM;
  static constexpr Cause STRIKE =
    Alert_Cause_STRIKE;
  static constexpr Cause DEMONSTRATION =
    Alert_Cause_DEMONSTRATION;
  static constexpr Cause ACCIDENT =
    Alert_Cause_ACCIDENT;
  static constexpr Cause HOLIDAY =
    Alert_Cause_HOLIDAY;
  static constexpr Cause WEATHER =
    Alert_Cause_WEATHER;
  static constexpr Cause MAINTENANCE =
    Alert_Cause_MAINTENANCE;
  static constexpr Cause CONSTRUCTION =
    Alert_Cause_CONSTRUCTION;
  static constexpr Cause POLICE_ACTIVITY =
    Alert_Cause_POLICE_ACTIVITY;
  static constexpr Cause MEDICAL_EMERGENCY =
    Alert_Cause_MEDICAL_EMERGENCY;
  static inline bool Cause_IsValid(int value) {
    return Alert_Cause_IsValid(value);
  }
  static constexpr Cause Cause_MIN =
    Alert_Cause_Cause_MIN;
  static constexpr Cause Cause_MAX =
    Alert_Cause_Cause_MAX;
  static constexpr int Cause_ARRAYSIZE =
    Alert_Cause_Cause_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Cause_descriptor() {
    return Alert_Cause_descriptor();
  }
  template<typename T>
  static inline const std::string& Cause_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Cause>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Cause_Name.");
    return Alert_Cause_Name(enum_t_value);
  }
  static inline bool Cause_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Cause* value) {
    return Alert_Cause_Parse(name, value);
  }

  typedef Alert_Effect Effect;
  static constexpr Effect PROTO3_DEFAULT_EFFECT =
    Alert_Effect_PROTO3_DEFAULT_EFFECT;
  static constexpr Effect NO_SERVICE =
    Alert_Effect_NO_SERVICE;
  static constexpr Effect REDUCED_SERVICE =
    Alert_Effect_REDUCED_SERVICE;
  static constexpr Effect SIGNIFICANT_DELAYS =
    Alert_Effect_SIGNIFICANT_DELAYS;
  static constexpr Effect DETOUR =
    Alert_Effect_DETOUR;
  static constexpr Effect ADDITIONAL_SERVICE =
    Alert_Effect_ADDITIONAL_SERVICE;
  static constexpr Effect MODIFIED_SERVICE =
    Alert_Effect_MODIFIED_SERVICE;
  static constexpr Effect OTHER_EFFECT =
    Alert_Effect_OTHER_EFFECT;
  static constexpr Effect UNKNOWN_EFFECT =
    Alert_Effect_UNKNOWN_EFFECT;
  static constexpr Effect STOP_MOVED =
    Alert_Effect_STOP_MOVED;
  static inline bool Effect_IsValid(int value) {
    return Alert_Effect_IsValid(value);
  }
  static constexpr Effect Effect_MIN =
    Alert_Effect_Effect_MIN;
  static constexpr Effect Effect_MAX =
    Alert_Effect_Effect_MAX;
  static constexpr int Effect_ARRAYSIZE =
    Alert_Effect_Effect_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Effect_descriptor() {
    return Alert_Effect_descriptor();
  }
  template<typename T>
  static inline const std::string& Effect_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Effect>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Effect_Name.");
    return Alert_Effect_Name(enum_t_value);
  }
  static inline bool Effect_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Effect* value) {
    return Alert_Effect_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActivePeriodFieldNumber = 1,
    kInformedEntityFieldNumber = 5,
    kUrlFieldNumber = 8,
    kHeaderTextFieldNumber = 10,
    kDescriptionTextFieldNumber = 11,
    kCauseFieldNumber = 6,
    kEffectFieldNumber = 7,
  };
  // repeated .MontrealSubwayRealtimeLocation.TimeRange active_period = 1;
  int active_period_size() const;
  private:
  int _internal_active_period_size() const;
  public:
  void clear_active_period();
  ::MontrealSubwayRealtimeLocation::TimeRange* mutable_active_period(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TimeRange >*
      mutable_active_period();
  private:
  const ::MontrealSubwayRealtimeLocation::TimeRange& _internal_active_period(int index) const;
  ::MontrealSubwayRealtimeLocation::TimeRange* _internal_add_active_period();
  public:
  const ::MontrealSubwayRealtimeLocation::TimeRange& active_period(int index) const;
  ::MontrealSubwayRealtimeLocation::TimeRange* add_active_period();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TimeRange >&
      active_period() const;

  // repeated .MontrealSubwayRealtimeLocation.EntitySelector informed_entity = 5;
  int informed_entity_size() const;
  private:
  int _internal_informed_entity_size() const;
  public:
  void clear_informed_entity();
  ::MontrealSubwayRealtimeLocation::EntitySelector* mutable_informed_entity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::EntitySelector >*
      mutable_informed_entity();
  private:
  const ::MontrealSubwayRealtimeLocation::EntitySelector& _internal_informed_entity(int index) const;
  ::MontrealSubwayRealtimeLocation::EntitySelector* _internal_add_informed_entity();
  public:
  const ::MontrealSubwayRealtimeLocation::EntitySelector& informed_entity(int index) const;
  ::MontrealSubwayRealtimeLocation::EntitySelector* add_informed_entity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::EntitySelector >&
      informed_entity() const;

  // .MontrealSubwayRealtimeLocation.TranslatedString url = 8;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const ::MontrealSubwayRealtimeLocation::TranslatedString& url() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::TranslatedString* release_url();
  ::MontrealSubwayRealtimeLocation::TranslatedString* mutable_url();
  void set_allocated_url(::MontrealSubwayRealtimeLocation::TranslatedString* url);
  private:
  const ::MontrealSubwayRealtimeLocation::TranslatedString& _internal_url() const;
  ::MontrealSubwayRealtimeLocation::TranslatedString* _internal_mutable_url();
  public:
  void unsafe_arena_set_allocated_url(
      ::MontrealSubwayRealtimeLocation::TranslatedString* url);
  ::MontrealSubwayRealtimeLocation::TranslatedString* unsafe_arena_release_url();

  // .MontrealSubwayRealtimeLocation.TranslatedString header_text = 10;
  bool has_header_text() const;
  private:
  bool _internal_has_header_text() const;
  public:
  void clear_header_text();
  const ::MontrealSubwayRealtimeLocation::TranslatedString& header_text() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::TranslatedString* release_header_text();
  ::MontrealSubwayRealtimeLocation::TranslatedString* mutable_header_text();
  void set_allocated_header_text(::MontrealSubwayRealtimeLocation::TranslatedString* header_text);
  private:
  const ::MontrealSubwayRealtimeLocation::TranslatedString& _internal_header_text() const;
  ::MontrealSubwayRealtimeLocation::TranslatedString* _internal_mutable_header_text();
  public:
  void unsafe_arena_set_allocated_header_text(
      ::MontrealSubwayRealtimeLocation::TranslatedString* header_text);
  ::MontrealSubwayRealtimeLocation::TranslatedString* unsafe_arena_release_header_text();

  // .MontrealSubwayRealtimeLocation.TranslatedString description_text = 11;
  bool has_description_text() const;
  private:
  bool _internal_has_description_text() const;
  public:
  void clear_description_text();
  const ::MontrealSubwayRealtimeLocation::TranslatedString& description_text() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::TranslatedString* release_description_text();
  ::MontrealSubwayRealtimeLocation::TranslatedString* mutable_description_text();
  void set_allocated_description_text(::MontrealSubwayRealtimeLocation::TranslatedString* description_text);
  private:
  const ::MontrealSubwayRealtimeLocation::TranslatedString& _internal_description_text() const;
  ::MontrealSubwayRealtimeLocation::TranslatedString* _internal_mutable_description_text();
  public:
  void unsafe_arena_set_allocated_description_text(
      ::MontrealSubwayRealtimeLocation::TranslatedString* description_text);
  ::MontrealSubwayRealtimeLocation::TranslatedString* unsafe_arena_release_description_text();

  // .MontrealSubwayRealtimeLocation.Alert.Cause cause = 6;
  void clear_cause();
  ::MontrealSubwayRealtimeLocation::Alert_Cause cause() const;
  void set_cause(::MontrealSubwayRealtimeLocation::Alert_Cause value);
  private:
  ::MontrealSubwayRealtimeLocation::Alert_Cause _internal_cause() const;
  void _internal_set_cause(::MontrealSubwayRealtimeLocation::Alert_Cause value);
  public:

  // .MontrealSubwayRealtimeLocation.Alert.Effect effect = 7;
  void clear_effect();
  ::MontrealSubwayRealtimeLocation::Alert_Effect effect() const;
  void set_effect(::MontrealSubwayRealtimeLocation::Alert_Effect value);
  private:
  ::MontrealSubwayRealtimeLocation::Alert_Effect _internal_effect() const;
  void _internal_set_effect(::MontrealSubwayRealtimeLocation::Alert_Effect value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.Alert)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TimeRange > active_period_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::EntitySelector > informed_entity_;
    ::MontrealSubwayRealtimeLocation::TranslatedString* url_;
    ::MontrealSubwayRealtimeLocation::TranslatedString* header_text_;
    ::MontrealSubwayRealtimeLocation::TranslatedString* description_text_;
    int cause_;
    int effect_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class TimeRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.TimeRange) */ {
 public:
  inline TimeRange() : TimeRange(nullptr) {}
  ~TimeRange() override;
  explicit PROTOBUF_CONSTEXPR TimeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeRange(const TimeRange& from);
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeRange& from) {
    TimeRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.TimeRange";
  }
  protected:
  explicit TimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // uint64 start = 1;
  void clear_start();
  uint64_t start() const;
  void set_start(uint64_t value);
  private:
  uint64_t _internal_start() const;
  void _internal_set_start(uint64_t value);
  public:

  // uint64 end = 2;
  void clear_end();
  uint64_t end() const;
  void set_end(uint64_t value);
  private:
  uint64_t _internal_end() const;
  void _internal_set_end(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.TimeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t start_;
    uint64_t end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kOdometerFieldNumber = 4,
    kBearingFieldNumber = 3,
    kSpeedFieldNumber = 5,
  };
  // float latitude = 1;
  void clear_latitude();
  float latitude() const;
  void set_latitude(float value);
  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);
  public:

  // float longitude = 2;
  void clear_longitude();
  float longitude() const;
  void set_longitude(float value);
  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);
  public:

  // double odometer = 4;
  void clear_odometer();
  double odometer() const;
  void set_odometer(double value);
  private:
  double _internal_odometer() const;
  void _internal_set_odometer(double value);
  public:

  // float bearing = 3;
  void clear_bearing();
  float bearing() const;
  void set_bearing(float value);
  private:
  float _internal_bearing() const;
  void _internal_set_bearing(float value);
  public:

  // float speed = 5;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float latitude_;
    float longitude_;
    double odometer_;
    float bearing_;
    float speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class TripDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.TripDescriptor) */ {
 public:
  inline TripDescriptor() : TripDescriptor(nullptr) {}
  ~TripDescriptor() override;
  explicit PROTOBUF_CONSTEXPR TripDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripDescriptor(const TripDescriptor& from);
  TripDescriptor(TripDescriptor&& from) noexcept
    : TripDescriptor() {
    *this = ::std::move(from);
  }

  inline TripDescriptor& operator=(const TripDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripDescriptor& operator=(TripDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripDescriptor* internal_default_instance() {
    return reinterpret_cast<const TripDescriptor*>(
               &_TripDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TripDescriptor& a, TripDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(TripDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripDescriptor& from) {
    TripDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.TripDescriptor";
  }
  protected:
  explicit TripDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TripDescriptor_ScheduleRelationship ScheduleRelationship;
  static constexpr ScheduleRelationship SCHEDULED =
    TripDescriptor_ScheduleRelationship_SCHEDULED;
  static constexpr ScheduleRelationship ADDED =
    TripDescriptor_ScheduleRelationship_ADDED;
  static constexpr ScheduleRelationship UNSCHEDULED =
    TripDescriptor_ScheduleRelationship_UNSCHEDULED;
  static constexpr ScheduleRelationship CANCELED =
    TripDescriptor_ScheduleRelationship_CANCELED;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripDescriptor_ScheduleRelationship_IsValid(value);
  }
  static constexpr ScheduleRelationship ScheduleRelationship_MIN =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN;
  static constexpr ScheduleRelationship ScheduleRelationship_MAX =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX;
  static constexpr int ScheduleRelationship_ARRAYSIZE =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScheduleRelationship_descriptor() {
    return TripDescriptor_ScheduleRelationship_descriptor();
  }
  template<typename T>
  static inline const std::string& ScheduleRelationship_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScheduleRelationship>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScheduleRelationship_Name.");
    return TripDescriptor_ScheduleRelationship_Name(enum_t_value);
  }
  static inline bool ScheduleRelationship_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScheduleRelationship* value) {
    return TripDescriptor_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTripIdFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kStartDateFieldNumber = 3,
    kRouteIdFieldNumber = 5,
    kScheduleRelationshipFieldNumber = 4,
    kDirectionIdFieldNumber = 6,
  };
  // string trip_id = 1;
  void clear_trip_id();
  const std::string& trip_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trip_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trip_id();
  PROTOBUF_NODISCARD std::string* release_trip_id();
  void set_allocated_trip_id(std::string* trip_id);
  private:
  const std::string& _internal_trip_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_id(const std::string& value);
  std::string* _internal_mutable_trip_id();
  public:

  // string start_time = 2;
  void clear_start_time();
  const std::string& start_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* start_time);
  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(const std::string& value);
  std::string* _internal_mutable_start_time();
  public:

  // string start_date = 3;
  void clear_start_date();
  const std::string& start_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* start_date);
  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(const std::string& value);
  std::string* _internal_mutable_start_date();
  public:

  // string route_id = 5;
  void clear_route_id();
  const std::string& route_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* route_id);
  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(const std::string& value);
  std::string* _internal_mutable_route_id();
  public:

  // .MontrealSubwayRealtimeLocation.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
  void clear_schedule_relationship();
  ::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship value);
  private:
  ::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship _internal_schedule_relationship() const;
  void _internal_set_schedule_relationship(::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship value);
  public:

  // uint32 direction_id = 6;
  void clear_direction_id();
  uint32_t direction_id() const;
  void set_direction_id(uint32_t value);
  private:
  uint32_t _internal_direction_id() const;
  void _internal_set_direction_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.TripDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trip_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
    int schedule_relationship_;
    uint32_t direction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class VehicleDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.VehicleDescriptor) */ {
 public:
  inline VehicleDescriptor() : VehicleDescriptor(nullptr) {}
  ~VehicleDescriptor() override;
  explicit PROTOBUF_CONSTEXPR VehicleDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehicleDescriptor(const VehicleDescriptor& from);
  VehicleDescriptor(VehicleDescriptor&& from) noexcept
    : VehicleDescriptor() {
    *this = ::std::move(from);
  }

  inline VehicleDescriptor& operator=(const VehicleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleDescriptor& operator=(VehicleDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleDescriptor* internal_default_instance() {
    return reinterpret_cast<const VehicleDescriptor*>(
               &_VehicleDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VehicleDescriptor& a, VehicleDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehicleDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehicleDescriptor& from) {
    VehicleDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.VehicleDescriptor";
  }
  protected:
  explicit VehicleDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLabelFieldNumber = 2,
    kLicensePlateFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // string license_plate = 3;
  void clear_license_plate();
  const std::string& license_plate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license_plate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license_plate();
  PROTOBUF_NODISCARD std::string* release_license_plate();
  void set_allocated_license_plate(std::string* license_plate);
  private:
  const std::string& _internal_license_plate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license_plate(const std::string& value);
  std::string* _internal_mutable_license_plate();
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.VehicleDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_plate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class EntitySelector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.EntitySelector) */ {
 public:
  inline EntitySelector() : EntitySelector(nullptr) {}
  ~EntitySelector() override;
  explicit PROTOBUF_CONSTEXPR EntitySelector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntitySelector(const EntitySelector& from);
  EntitySelector(EntitySelector&& from) noexcept
    : EntitySelector() {
    *this = ::std::move(from);
  }

  inline EntitySelector& operator=(const EntitySelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntitySelector& operator=(EntitySelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntitySelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntitySelector* internal_default_instance() {
    return reinterpret_cast<const EntitySelector*>(
               &_EntitySelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EntitySelector& a, EntitySelector& b) {
    a.Swap(&b);
  }
  inline void Swap(EntitySelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntitySelector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntitySelector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntitySelector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntitySelector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntitySelector& from) {
    EntitySelector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntitySelector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.EntitySelector";
  }
  protected:
  explicit EntitySelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgencyIdFieldNumber = 1,
    kRouteIdFieldNumber = 2,
    kStopIdFieldNumber = 5,
    kTripFieldNumber = 4,
    kRouteTypeFieldNumber = 3,
  };
  // string agency_id = 1;
  void clear_agency_id();
  const std::string& agency_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_id();
  PROTOBUF_NODISCARD std::string* release_agency_id();
  void set_allocated_agency_id(std::string* agency_id);
  private:
  const std::string& _internal_agency_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_id(const std::string& value);
  std::string* _internal_mutable_agency_id();
  public:

  // string route_id = 2;
  void clear_route_id();
  const std::string& route_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* route_id);
  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(const std::string& value);
  std::string* _internal_mutable_route_id();
  public:

  // string stop_id = 5;
  void clear_stop_id();
  const std::string& stop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* stop_id);
  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(const std::string& value);
  std::string* _internal_mutable_stop_id();
  public:

  // .MontrealSubwayRealtimeLocation.TripDescriptor trip = 4;
  bool has_trip() const;
  private:
  bool _internal_has_trip() const;
  public:
  void clear_trip();
  const ::MontrealSubwayRealtimeLocation::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::MontrealSubwayRealtimeLocation::TripDescriptor* release_trip();
  ::MontrealSubwayRealtimeLocation::TripDescriptor* mutable_trip();
  void set_allocated_trip(::MontrealSubwayRealtimeLocation::TripDescriptor* trip);
  private:
  const ::MontrealSubwayRealtimeLocation::TripDescriptor& _internal_trip() const;
  ::MontrealSubwayRealtimeLocation::TripDescriptor* _internal_mutable_trip();
  public:
  void unsafe_arena_set_allocated_trip(
      ::MontrealSubwayRealtimeLocation::TripDescriptor* trip);
  ::MontrealSubwayRealtimeLocation::TripDescriptor* unsafe_arena_release_trip();

  // int32 route_type = 3;
  void clear_route_type();
  int32_t route_type() const;
  void set_route_type(int32_t value);
  private:
  int32_t _internal_route_type() const;
  void _internal_set_route_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.EntitySelector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
    ::MontrealSubwayRealtimeLocation::TripDescriptor* trip_;
    int32_t route_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class TranslatedString_Translation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.TranslatedString.Translation) */ {
 public:
  inline TranslatedString_Translation() : TranslatedString_Translation(nullptr) {}
  ~TranslatedString_Translation() override;
  explicit PROTOBUF_CONSTEXPR TranslatedString_Translation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranslatedString_Translation(const TranslatedString_Translation& from);
  TranslatedString_Translation(TranslatedString_Translation&& from) noexcept
    : TranslatedString_Translation() {
    *this = ::std::move(from);
  }

  inline TranslatedString_Translation& operator=(const TranslatedString_Translation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedString_Translation& operator=(TranslatedString_Translation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedString_Translation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedString_Translation* internal_default_instance() {
    return reinterpret_cast<const TranslatedString_Translation*>(
               &_TranslatedString_Translation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TranslatedString_Translation& a, TranslatedString_Translation& b) {
    a.Swap(&b);
  }
  inline void Swap(TranslatedString_Translation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedString_Translation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedString_Translation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranslatedString_Translation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranslatedString_Translation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranslatedString_Translation& from) {
    TranslatedString_Translation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranslatedString_Translation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.TranslatedString.Translation";
  }
  protected:
  explicit TranslatedString_Translation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kLanguageFieldNumber = 2,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string language = 2;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.TranslatedString.Translation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// -------------------------------------------------------------------

class TranslatedString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MontrealSubwayRealtimeLocation.TranslatedString) */ {
 public:
  inline TranslatedString() : TranslatedString(nullptr) {}
  ~TranslatedString() override;
  explicit PROTOBUF_CONSTEXPR TranslatedString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranslatedString(const TranslatedString& from);
  TranslatedString(TranslatedString&& from) noexcept
    : TranslatedString() {
    *this = ::std::move(from);
  }

  inline TranslatedString& operator=(const TranslatedString& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedString& operator=(TranslatedString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedString& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedString* internal_default_instance() {
    return reinterpret_cast<const TranslatedString*>(
               &_TranslatedString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TranslatedString& a, TranslatedString& b) {
    a.Swap(&b);
  }
  inline void Swap(TranslatedString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranslatedString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranslatedString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranslatedString& from) {
    TranslatedString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranslatedString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MontrealSubwayRealtimeLocation.TranslatedString";
  }
  protected:
  explicit TranslatedString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TranslatedString_Translation Translation;

  // accessors -------------------------------------------------------

  enum : int {
    kTranslationFieldNumber = 1,
  };
  // repeated .MontrealSubwayRealtimeLocation.TranslatedString.Translation translation = 1;
  int translation_size() const;
  private:
  int _internal_translation_size() const;
  public:
  void clear_translation();
  ::MontrealSubwayRealtimeLocation::TranslatedString_Translation* mutable_translation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TranslatedString_Translation >*
      mutable_translation();
  private:
  const ::MontrealSubwayRealtimeLocation::TranslatedString_Translation& _internal_translation(int index) const;
  ::MontrealSubwayRealtimeLocation::TranslatedString_Translation* _internal_add_translation();
  public:
  const ::MontrealSubwayRealtimeLocation::TranslatedString_Translation& translation(int index) const;
  ::MontrealSubwayRealtimeLocation::TranslatedString_Translation* add_translation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TranslatedString_Translation >&
      translation() const;

  // @@protoc_insertion_point(class_scope:MontrealSubwayRealtimeLocation.TranslatedString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TranslatedString_Translation > translation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto3;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FeedMessage

// .MontrealSubwayRealtimeLocation.FeedHeader header = 1;
inline bool FeedMessage::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FeedMessage::has_header() const {
  return _internal_has_header();
}
inline void FeedMessage::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::FeedHeader& FeedMessage::_internal_header() const {
  const ::MontrealSubwayRealtimeLocation::FeedHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::FeedHeader&>(
      ::MontrealSubwayRealtimeLocation::_FeedHeader_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::FeedHeader& FeedMessage::header() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedMessage.header)
  return _internal_header();
}
inline void FeedMessage::unsafe_arena_set_allocated_header(
    ::MontrealSubwayRealtimeLocation::FeedHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.FeedMessage.header)
}
inline ::MontrealSubwayRealtimeLocation::FeedHeader* FeedMessage::release_header() {
  
  ::MontrealSubwayRealtimeLocation::FeedHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::FeedHeader* FeedMessage::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.FeedMessage.header)
  
  ::MontrealSubwayRealtimeLocation::FeedHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::FeedHeader* FeedMessage::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::FeedHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::MontrealSubwayRealtimeLocation::FeedHeader* FeedMessage::mutable_header() {
  ::MontrealSubwayRealtimeLocation::FeedHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.FeedMessage.header)
  return _msg;
}
inline void FeedMessage::set_allocated_header(::MontrealSubwayRealtimeLocation::FeedHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.FeedMessage.header)
}

// repeated .MontrealSubwayRealtimeLocation.FeedEntity entity = 2;
inline int FeedMessage::_internal_entity_size() const {
  return _impl_.entity_.size();
}
inline int FeedMessage::entity_size() const {
  return _internal_entity_size();
}
inline void FeedMessage::clear_entity() {
  _impl_.entity_.Clear();
}
inline ::MontrealSubwayRealtimeLocation::FeedEntity* FeedMessage::mutable_entity(int index) {
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.FeedMessage.entity)
  return _impl_.entity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::FeedEntity >*
FeedMessage::mutable_entity() {
  // @@protoc_insertion_point(field_mutable_list:MontrealSubwayRealtimeLocation.FeedMessage.entity)
  return &_impl_.entity_;
}
inline const ::MontrealSubwayRealtimeLocation::FeedEntity& FeedMessage::_internal_entity(int index) const {
  return _impl_.entity_.Get(index);
}
inline const ::MontrealSubwayRealtimeLocation::FeedEntity& FeedMessage::entity(int index) const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedMessage.entity)
  return _internal_entity(index);
}
inline ::MontrealSubwayRealtimeLocation::FeedEntity* FeedMessage::_internal_add_entity() {
  return _impl_.entity_.Add();
}
inline ::MontrealSubwayRealtimeLocation::FeedEntity* FeedMessage::add_entity() {
  ::MontrealSubwayRealtimeLocation::FeedEntity* _add = _internal_add_entity();
  // @@protoc_insertion_point(field_add:MontrealSubwayRealtimeLocation.FeedMessage.entity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::FeedEntity >&
FeedMessage::entity() const {
  // @@protoc_insertion_point(field_list:MontrealSubwayRealtimeLocation.FeedMessage.entity)
  return _impl_.entity_;
}

// -------------------------------------------------------------------

// FeedHeader

// string gtfs_realtime_version = 1;
inline void FeedHeader::clear_gtfs_realtime_version() {
  _impl_.gtfs_realtime_version_.ClearToEmpty();
}
inline const std::string& FeedHeader::gtfs_realtime_version() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedHeader.gtfs_realtime_version)
  return _internal_gtfs_realtime_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedHeader::set_gtfs_realtime_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gtfs_realtime_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.FeedHeader.gtfs_realtime_version)
}
inline std::string* FeedHeader::mutable_gtfs_realtime_version() {
  std::string* _s = _internal_mutable_gtfs_realtime_version();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.FeedHeader.gtfs_realtime_version)
  return _s;
}
inline const std::string& FeedHeader::_internal_gtfs_realtime_version() const {
  return _impl_.gtfs_realtime_version_.Get();
}
inline void FeedHeader::_internal_set_gtfs_realtime_version(const std::string& value) {
  
  _impl_.gtfs_realtime_version_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedHeader::_internal_mutable_gtfs_realtime_version() {
  
  return _impl_.gtfs_realtime_version_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedHeader::release_gtfs_realtime_version() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.FeedHeader.gtfs_realtime_version)
  return _impl_.gtfs_realtime_version_.Release();
}
inline void FeedHeader::set_allocated_gtfs_realtime_version(std::string* gtfs_realtime_version) {
  if (gtfs_realtime_version != nullptr) {
    
  } else {
    
  }
  _impl_.gtfs_realtime_version_.SetAllocated(gtfs_realtime_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gtfs_realtime_version_.IsDefault()) {
    _impl_.gtfs_realtime_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.FeedHeader.gtfs_realtime_version)
}

// .MontrealSubwayRealtimeLocation.FeedHeader.Incrementality incrementality = 2;
inline void FeedHeader::clear_incrementality() {
  _impl_.incrementality_ = 0;
}
inline ::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality FeedHeader::_internal_incrementality() const {
  return static_cast< ::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality >(_impl_.incrementality_);
}
inline ::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality FeedHeader::incrementality() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedHeader.incrementality)
  return _internal_incrementality();
}
inline void FeedHeader::_internal_set_incrementality(::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality value) {
  
  _impl_.incrementality_ = value;
}
inline void FeedHeader::set_incrementality(::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality value) {
  _internal_set_incrementality(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.FeedHeader.incrementality)
}

// uint64 timestamp = 3;
inline void FeedHeader::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t FeedHeader::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t FeedHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedHeader.timestamp)
  return _internal_timestamp();
}
inline void FeedHeader::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void FeedHeader::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.FeedHeader.timestamp)
}

// -------------------------------------------------------------------

// FeedEntity

// string id = 1;
inline void FeedEntity::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& FeedEntity::id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedEntity.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedEntity::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.FeedEntity.id)
}
inline std::string* FeedEntity::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.FeedEntity.id)
  return _s;
}
inline const std::string& FeedEntity::_internal_id() const {
  return _impl_.id_.Get();
}
inline void FeedEntity::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedEntity::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedEntity::release_id() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.FeedEntity.id)
  return _impl_.id_.Release();
}
inline void FeedEntity::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.FeedEntity.id)
}

// bool is_deleted = 2;
inline void FeedEntity::clear_is_deleted() {
  _impl_.is_deleted_ = false;
}
inline bool FeedEntity::_internal_is_deleted() const {
  return _impl_.is_deleted_;
}
inline bool FeedEntity::is_deleted() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedEntity.is_deleted)
  return _internal_is_deleted();
}
inline void FeedEntity::_internal_set_is_deleted(bool value) {
  
  _impl_.is_deleted_ = value;
}
inline void FeedEntity::set_is_deleted(bool value) {
  _internal_set_is_deleted(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.FeedEntity.is_deleted)
}

// .MontrealSubwayRealtimeLocation.TripUpdate trip_update = 3;
inline bool FeedEntity::_internal_has_trip_update() const {
  return this != internal_default_instance() && _impl_.trip_update_ != nullptr;
}
inline bool FeedEntity::has_trip_update() const {
  return _internal_has_trip_update();
}
inline void FeedEntity::clear_trip_update() {
  if (GetArenaForAllocation() == nullptr && _impl_.trip_update_ != nullptr) {
    delete _impl_.trip_update_;
  }
  _impl_.trip_update_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::TripUpdate& FeedEntity::_internal_trip_update() const {
  const ::MontrealSubwayRealtimeLocation::TripUpdate* p = _impl_.trip_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::TripUpdate&>(
      ::MontrealSubwayRealtimeLocation::_TripUpdate_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::TripUpdate& FeedEntity::trip_update() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedEntity.trip_update)
  return _internal_trip_update();
}
inline void FeedEntity::unsafe_arena_set_allocated_trip_update(
    ::MontrealSubwayRealtimeLocation::TripUpdate* trip_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_update_);
  }
  _impl_.trip_update_ = trip_update;
  if (trip_update) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.FeedEntity.trip_update)
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate* FeedEntity::release_trip_update() {
  
  ::MontrealSubwayRealtimeLocation::TripUpdate* temp = _impl_.trip_update_;
  _impl_.trip_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate* FeedEntity::unsafe_arena_release_trip_update() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.FeedEntity.trip_update)
  
  ::MontrealSubwayRealtimeLocation::TripUpdate* temp = _impl_.trip_update_;
  _impl_.trip_update_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate* FeedEntity::_internal_mutable_trip_update() {
  
  if (_impl_.trip_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripUpdate>(GetArenaForAllocation());
    _impl_.trip_update_ = p;
  }
  return _impl_.trip_update_;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate* FeedEntity::mutable_trip_update() {
  ::MontrealSubwayRealtimeLocation::TripUpdate* _msg = _internal_mutable_trip_update();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.FeedEntity.trip_update)
  return _msg;
}
inline void FeedEntity::set_allocated_trip_update(::MontrealSubwayRealtimeLocation::TripUpdate* trip_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_update_;
  }
  if (trip_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip_update);
    if (message_arena != submessage_arena) {
      trip_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip_update, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trip_update_ = trip_update;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.FeedEntity.trip_update)
}

// .MontrealSubwayRealtimeLocation.VehiclePosition vehicle = 4;
inline bool FeedEntity::_internal_has_vehicle() const {
  return this != internal_default_instance() && _impl_.vehicle_ != nullptr;
}
inline bool FeedEntity::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void FeedEntity::clear_vehicle() {
  if (GetArenaForAllocation() == nullptr && _impl_.vehicle_ != nullptr) {
    delete _impl_.vehicle_;
  }
  _impl_.vehicle_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::VehiclePosition& FeedEntity::_internal_vehicle() const {
  const ::MontrealSubwayRealtimeLocation::VehiclePosition* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::VehiclePosition&>(
      ::MontrealSubwayRealtimeLocation::_VehiclePosition_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::VehiclePosition& FeedEntity::vehicle() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedEntity.vehicle)
  return _internal_vehicle();
}
inline void FeedEntity::unsafe_arena_set_allocated_vehicle(
    ::MontrealSubwayRealtimeLocation::VehiclePosition* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.FeedEntity.vehicle)
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition* FeedEntity::release_vehicle() {
  
  ::MontrealSubwayRealtimeLocation::VehiclePosition* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition* FeedEntity::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.FeedEntity.vehicle)
  
  ::MontrealSubwayRealtimeLocation::VehiclePosition* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition* FeedEntity::_internal_mutable_vehicle() {
  
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::VehiclePosition>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition* FeedEntity::mutable_vehicle() {
  ::MontrealSubwayRealtimeLocation::VehiclePosition* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.FeedEntity.vehicle)
  return _msg;
}
inline void FeedEntity::set_allocated_vehicle(::MontrealSubwayRealtimeLocation::VehiclePosition* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.FeedEntity.vehicle)
}

// .MontrealSubwayRealtimeLocation.Alert alert = 5;
inline bool FeedEntity::_internal_has_alert() const {
  return this != internal_default_instance() && _impl_.alert_ != nullptr;
}
inline bool FeedEntity::has_alert() const {
  return _internal_has_alert();
}
inline void FeedEntity::clear_alert() {
  if (GetArenaForAllocation() == nullptr && _impl_.alert_ != nullptr) {
    delete _impl_.alert_;
  }
  _impl_.alert_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::Alert& FeedEntity::_internal_alert() const {
  const ::MontrealSubwayRealtimeLocation::Alert* p = _impl_.alert_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::Alert&>(
      ::MontrealSubwayRealtimeLocation::_Alert_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::Alert& FeedEntity::alert() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.FeedEntity.alert)
  return _internal_alert();
}
inline void FeedEntity::unsafe_arena_set_allocated_alert(
    ::MontrealSubwayRealtimeLocation::Alert* alert) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_);
  }
  _impl_.alert_ = alert;
  if (alert) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.FeedEntity.alert)
}
inline ::MontrealSubwayRealtimeLocation::Alert* FeedEntity::release_alert() {
  
  ::MontrealSubwayRealtimeLocation::Alert* temp = _impl_.alert_;
  _impl_.alert_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::Alert* FeedEntity::unsafe_arena_release_alert() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.FeedEntity.alert)
  
  ::MontrealSubwayRealtimeLocation::Alert* temp = _impl_.alert_;
  _impl_.alert_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::Alert* FeedEntity::_internal_mutable_alert() {
  
  if (_impl_.alert_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::Alert>(GetArenaForAllocation());
    _impl_.alert_ = p;
  }
  return _impl_.alert_;
}
inline ::MontrealSubwayRealtimeLocation::Alert* FeedEntity::mutable_alert() {
  ::MontrealSubwayRealtimeLocation::Alert* _msg = _internal_mutable_alert();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.FeedEntity.alert)
  return _msg;
}
inline void FeedEntity::set_allocated_alert(::MontrealSubwayRealtimeLocation::Alert* alert) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.alert_;
  }
  if (alert) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(alert);
    if (message_arena != submessage_arena) {
      alert = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alert, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.alert_ = alert;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.FeedEntity.alert)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeEvent

// int32 delay = 1;
inline void TripUpdate_StopTimeEvent::clear_delay() {
  _impl_.delay_ = 0;
}
inline int32_t TripUpdate_StopTimeEvent::_internal_delay() const {
  return _impl_.delay_;
}
inline int32_t TripUpdate_StopTimeEvent::delay() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent.delay)
  return _internal_delay();
}
inline void TripUpdate_StopTimeEvent::_internal_set_delay(int32_t value) {
  
  _impl_.delay_ = value;
}
inline void TripUpdate_StopTimeEvent::set_delay(int32_t value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent.delay)
}

// int64 time = 2;
inline void TripUpdate_StopTimeEvent::clear_time() {
  _impl_.time_ = int64_t{0};
}
inline int64_t TripUpdate_StopTimeEvent::_internal_time() const {
  return _impl_.time_;
}
inline int64_t TripUpdate_StopTimeEvent::time() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent.time)
  return _internal_time();
}
inline void TripUpdate_StopTimeEvent::_internal_set_time(int64_t value) {
  
  _impl_.time_ = value;
}
inline void TripUpdate_StopTimeEvent::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent.time)
}

// int32 uncertainty = 3;
inline void TripUpdate_StopTimeEvent::clear_uncertainty() {
  _impl_.uncertainty_ = 0;
}
inline int32_t TripUpdate_StopTimeEvent::_internal_uncertainty() const {
  return _impl_.uncertainty_;
}
inline int32_t TripUpdate_StopTimeEvent::uncertainty() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent.uncertainty)
  return _internal_uncertainty();
}
inline void TripUpdate_StopTimeEvent::_internal_set_uncertainty(int32_t value) {
  
  _impl_.uncertainty_ = value;
}
inline void TripUpdate_StopTimeEvent::set_uncertainty(int32_t value) {
  _internal_set_uncertainty(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent.uncertainty)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeUpdate

// uint32 stop_sequence = 1;
inline void TripUpdate_StopTimeUpdate::clear_stop_sequence() {
  _impl_.stop_sequence_ = 0u;
}
inline uint32_t TripUpdate_StopTimeUpdate::_internal_stop_sequence() const {
  return _impl_.stop_sequence_;
}
inline uint32_t TripUpdate_StopTimeUpdate::stop_sequence() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.stop_sequence)
  return _internal_stop_sequence();
}
inline void TripUpdate_StopTimeUpdate::_internal_set_stop_sequence(uint32_t value) {
  
  _impl_.stop_sequence_ = value;
}
inline void TripUpdate_StopTimeUpdate::set_stop_sequence(uint32_t value) {
  _internal_set_stop_sequence(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.stop_sequence)
}

// string stop_id = 4;
inline void TripUpdate_StopTimeUpdate::clear_stop_id() {
  _impl_.stop_id_.ClearToEmpty();
}
inline const std::string& TripUpdate_StopTimeUpdate::stop_id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.stop_id)
  return _internal_stop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripUpdate_StopTimeUpdate::set_stop_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stop_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.stop_id)
}
inline std::string* TripUpdate_StopTimeUpdate::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.stop_id)
  return _s;
}
inline const std::string& TripUpdate_StopTimeUpdate::_internal_stop_id() const {
  return _impl_.stop_id_.Get();
}
inline void TripUpdate_StopTimeUpdate::_internal_set_stop_id(const std::string& value) {
  
  _impl_.stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripUpdate_StopTimeUpdate::_internal_mutable_stop_id() {
  
  return _impl_.stop_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TripUpdate_StopTimeUpdate::release_stop_id() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.stop_id)
  return _impl_.stop_id_.Release();
}
inline void TripUpdate_StopTimeUpdate::set_allocated_stop_id(std::string* stop_id) {
  if (stop_id != nullptr) {
    
  } else {
    
  }
  _impl_.stop_id_.SetAllocated(stop_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.stop_id)
}

// .MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent arrival = 2;
inline bool TripUpdate_StopTimeUpdate::_internal_has_arrival() const {
  return this != internal_default_instance() && _impl_.arrival_ != nullptr;
}
inline bool TripUpdate_StopTimeUpdate::has_arrival() const {
  return _internal_has_arrival();
}
inline void TripUpdate_StopTimeUpdate::clear_arrival() {
  if (GetArenaForAllocation() == nullptr && _impl_.arrival_ != nullptr) {
    delete _impl_.arrival_;
  }
  _impl_.arrival_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::_internal_arrival() const {
  const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* p = _impl_.arrival_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent&>(
      ::MontrealSubwayRealtimeLocation::_TripUpdate_StopTimeEvent_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::arrival() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.arrival)
  return _internal_arrival();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_arrival(
    ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* arrival) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_);
  }
  _impl_.arrival_ = arrival;
  if (arrival) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.arrival)
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_arrival() {
  
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::unsafe_arena_release_arrival() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.arrival)
  
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::_internal_mutable_arrival() {
  
  if (_impl_.arrival_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent>(GetArenaForAllocation());
    _impl_.arrival_ = p;
  }
  return _impl_.arrival_;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_arrival() {
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* _msg = _internal_mutable_arrival();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.arrival)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_arrival(::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* arrival) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arrival_;
  }
  if (arrival) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arrival);
    if (message_arena != submessage_arena) {
      arrival = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrival, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arrival_ = arrival;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.arrival)
}

// .MontrealSubwayRealtimeLocation.TripUpdate.StopTimeEvent departure = 3;
inline bool TripUpdate_StopTimeUpdate::_internal_has_departure() const {
  return this != internal_default_instance() && _impl_.departure_ != nullptr;
}
inline bool TripUpdate_StopTimeUpdate::has_departure() const {
  return _internal_has_departure();
}
inline void TripUpdate_StopTimeUpdate::clear_departure() {
  if (GetArenaForAllocation() == nullptr && _impl_.departure_ != nullptr) {
    delete _impl_.departure_;
  }
  _impl_.departure_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::_internal_departure() const {
  const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* p = _impl_.departure_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent&>(
      ::MontrealSubwayRealtimeLocation::_TripUpdate_StopTimeEvent_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::departure() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.departure)
  return _internal_departure();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_departure(
    ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* departure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_);
  }
  _impl_.departure_ = departure;
  if (departure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.departure)
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_departure() {
  
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::unsafe_arena_release_departure() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.departure)
  
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::_internal_mutable_departure() {
  
  if (_impl_.departure_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent>(GetArenaForAllocation());
    _impl_.departure_ = p;
  }
  return _impl_.departure_;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_departure() {
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* _msg = _internal_mutable_departure();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.departure)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_departure(::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeEvent* departure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.departure_;
  }
  if (departure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(departure);
    if (message_arena != submessage_arena) {
      departure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, departure, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.departure_ = departure;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.departure)
}

// .MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5;
inline void TripUpdate_StopTimeUpdate::clear_schedule_relationship() {
  _impl_.schedule_relationship_ = 0;
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::_internal_schedule_relationship() const {
  return static_cast< ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship >(_impl_.schedule_relationship_);
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.schedule_relationship)
  return _internal_schedule_relationship();
}
inline void TripUpdate_StopTimeUpdate::_internal_set_schedule_relationship(::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  
  _impl_.schedule_relationship_ = value;
}
inline void TripUpdate_StopTimeUpdate::set_schedule_relationship(::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  _internal_set_schedule_relationship(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate.schedule_relationship)
}

// -------------------------------------------------------------------

// TripUpdate

// .MontrealSubwayRealtimeLocation.TripDescriptor trip = 1;
inline bool TripUpdate::_internal_has_trip() const {
  return this != internal_default_instance() && _impl_.trip_ != nullptr;
}
inline bool TripUpdate::has_trip() const {
  return _internal_has_trip();
}
inline void TripUpdate::clear_trip() {
  if (GetArenaForAllocation() == nullptr && _impl_.trip_ != nullptr) {
    delete _impl_.trip_;
  }
  _impl_.trip_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::TripDescriptor& TripUpdate::_internal_trip() const {
  const ::MontrealSubwayRealtimeLocation::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::TripDescriptor&>(
      ::MontrealSubwayRealtimeLocation::_TripDescriptor_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::TripDescriptor& TripUpdate::trip() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.trip)
  return _internal_trip();
}
inline void TripUpdate::unsafe_arena_set_allocated_trip(
    ::MontrealSubwayRealtimeLocation::TripDescriptor* trip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = trip;
  if (trip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.TripUpdate.trip)
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* TripUpdate::release_trip() {
  
  ::MontrealSubwayRealtimeLocation::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* TripUpdate::unsafe_arena_release_trip() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TripUpdate.trip)
  
  ::MontrealSubwayRealtimeLocation::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* TripUpdate::_internal_mutable_trip() {
  
  if (_impl_.trip_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripDescriptor>(GetArenaForAllocation());
    _impl_.trip_ = p;
  }
  return _impl_.trip_;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* TripUpdate::mutable_trip() {
  ::MontrealSubwayRealtimeLocation::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripUpdate.trip)
  return _msg;
}
inline void TripUpdate::set_allocated_trip(::MontrealSubwayRealtimeLocation::TripDescriptor* trip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_;
  }
  if (trip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip);
    if (message_arena != submessage_arena) {
      trip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trip_ = trip;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TripUpdate.trip)
}

// .MontrealSubwayRealtimeLocation.VehicleDescriptor vehicle = 3;
inline bool TripUpdate::_internal_has_vehicle() const {
  return this != internal_default_instance() && _impl_.vehicle_ != nullptr;
}
inline bool TripUpdate::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void TripUpdate::clear_vehicle() {
  if (GetArenaForAllocation() == nullptr && _impl_.vehicle_ != nullptr) {
    delete _impl_.vehicle_;
  }
  _impl_.vehicle_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::VehicleDescriptor& TripUpdate::_internal_vehicle() const {
  const ::MontrealSubwayRealtimeLocation::VehicleDescriptor* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::VehicleDescriptor&>(
      ::MontrealSubwayRealtimeLocation::_VehicleDescriptor_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::VehicleDescriptor& TripUpdate::vehicle() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.vehicle)
  return _internal_vehicle();
}
inline void TripUpdate::unsafe_arena_set_allocated_vehicle(
    ::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.TripUpdate.vehicle)
}
inline ::MontrealSubwayRealtimeLocation::VehicleDescriptor* TripUpdate::release_vehicle() {
  
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::VehicleDescriptor* TripUpdate::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TripUpdate.vehicle)
  
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::VehicleDescriptor* TripUpdate::_internal_mutable_vehicle() {
  
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::VehicleDescriptor>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::MontrealSubwayRealtimeLocation::VehicleDescriptor* TripUpdate::mutable_vehicle() {
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripUpdate.vehicle)
  return _msg;
}
inline void TripUpdate::set_allocated_vehicle(::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TripUpdate.vehicle)
}

// repeated .MontrealSubwayRealtimeLocation.TripUpdate.StopTimeUpdate stop_time_update = 2;
inline int TripUpdate::_internal_stop_time_update_size() const {
  return _impl_.stop_time_update_.size();
}
inline int TripUpdate::stop_time_update_size() const {
  return _internal_stop_time_update_size();
}
inline void TripUpdate::clear_stop_time_update() {
  _impl_.stop_time_update_.Clear();
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate* TripUpdate::mutable_stop_time_update(int index) {
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripUpdate.stop_time_update)
  return _impl_.stop_time_update_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate >*
TripUpdate::mutable_stop_time_update() {
  // @@protoc_insertion_point(field_mutable_list:MontrealSubwayRealtimeLocation.TripUpdate.stop_time_update)
  return &_impl_.stop_time_update_;
}
inline const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate& TripUpdate::_internal_stop_time_update(int index) const {
  return _impl_.stop_time_update_.Get(index);
}
inline const ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate& TripUpdate::stop_time_update(int index) const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.stop_time_update)
  return _internal_stop_time_update(index);
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate* TripUpdate::_internal_add_stop_time_update() {
  return _impl_.stop_time_update_.Add();
}
inline ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate* TripUpdate::add_stop_time_update() {
  ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate* _add = _internal_add_stop_time_update();
  // @@protoc_insertion_point(field_add:MontrealSubwayRealtimeLocation.TripUpdate.stop_time_update)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate >&
TripUpdate::stop_time_update() const {
  // @@protoc_insertion_point(field_list:MontrealSubwayRealtimeLocation.TripUpdate.stop_time_update)
  return _impl_.stop_time_update_;
}

// uint64 timestamp = 4;
inline void TripUpdate::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t TripUpdate::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t TripUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.timestamp)
  return _internal_timestamp();
}
inline void TripUpdate::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void TripUpdate::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripUpdate.timestamp)
}

// int32 delay = 5;
inline void TripUpdate::clear_delay() {
  _impl_.delay_ = 0;
}
inline int32_t TripUpdate::_internal_delay() const {
  return _impl_.delay_;
}
inline int32_t TripUpdate::delay() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripUpdate.delay)
  return _internal_delay();
}
inline void TripUpdate::_internal_set_delay(int32_t value) {
  
  _impl_.delay_ = value;
}
inline void TripUpdate::set_delay(int32_t value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripUpdate.delay)
}

// -------------------------------------------------------------------

// VehiclePosition

// .MontrealSubwayRealtimeLocation.TripDescriptor trip = 1;
inline bool VehiclePosition::_internal_has_trip() const {
  return this != internal_default_instance() && _impl_.trip_ != nullptr;
}
inline bool VehiclePosition::has_trip() const {
  return _internal_has_trip();
}
inline void VehiclePosition::clear_trip() {
  if (GetArenaForAllocation() == nullptr && _impl_.trip_ != nullptr) {
    delete _impl_.trip_;
  }
  _impl_.trip_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::TripDescriptor& VehiclePosition::_internal_trip() const {
  const ::MontrealSubwayRealtimeLocation::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::TripDescriptor&>(
      ::MontrealSubwayRealtimeLocation::_TripDescriptor_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::TripDescriptor& VehiclePosition::trip() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehiclePosition.trip)
  return _internal_trip();
}
inline void VehiclePosition::unsafe_arena_set_allocated_trip(
    ::MontrealSubwayRealtimeLocation::TripDescriptor* trip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = trip;
  if (trip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.VehiclePosition.trip)
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* VehiclePosition::release_trip() {
  
  ::MontrealSubwayRealtimeLocation::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* VehiclePosition::unsafe_arena_release_trip() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.VehiclePosition.trip)
  
  ::MontrealSubwayRealtimeLocation::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* VehiclePosition::_internal_mutable_trip() {
  
  if (_impl_.trip_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripDescriptor>(GetArenaForAllocation());
    _impl_.trip_ = p;
  }
  return _impl_.trip_;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* VehiclePosition::mutable_trip() {
  ::MontrealSubwayRealtimeLocation::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.VehiclePosition.trip)
  return _msg;
}
inline void VehiclePosition::set_allocated_trip(::MontrealSubwayRealtimeLocation::TripDescriptor* trip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_;
  }
  if (trip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip);
    if (message_arena != submessage_arena) {
      trip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trip_ = trip;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.VehiclePosition.trip)
}

// .MontrealSubwayRealtimeLocation.VehicleDescriptor vehicle = 8;
inline bool VehiclePosition::_internal_has_vehicle() const {
  return this != internal_default_instance() && _impl_.vehicle_ != nullptr;
}
inline bool VehiclePosition::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void VehiclePosition::clear_vehicle() {
  if (GetArenaForAllocation() == nullptr && _impl_.vehicle_ != nullptr) {
    delete _impl_.vehicle_;
  }
  _impl_.vehicle_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::VehicleDescriptor& VehiclePosition::_internal_vehicle() const {
  const ::MontrealSubwayRealtimeLocation::VehicleDescriptor* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::VehicleDescriptor&>(
      ::MontrealSubwayRealtimeLocation::_VehicleDescriptor_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::VehicleDescriptor& VehiclePosition::vehicle() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehiclePosition.vehicle)
  return _internal_vehicle();
}
inline void VehiclePosition::unsafe_arena_set_allocated_vehicle(
    ::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.VehiclePosition.vehicle)
}
inline ::MontrealSubwayRealtimeLocation::VehicleDescriptor* VehiclePosition::release_vehicle() {
  
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::VehicleDescriptor* VehiclePosition::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.VehiclePosition.vehicle)
  
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::VehicleDescriptor* VehiclePosition::_internal_mutable_vehicle() {
  
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::VehicleDescriptor>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::MontrealSubwayRealtimeLocation::VehicleDescriptor* VehiclePosition::mutable_vehicle() {
  ::MontrealSubwayRealtimeLocation::VehicleDescriptor* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.VehiclePosition.vehicle)
  return _msg;
}
inline void VehiclePosition::set_allocated_vehicle(::MontrealSubwayRealtimeLocation::VehicleDescriptor* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.VehiclePosition.vehicle)
}

// .MontrealSubwayRealtimeLocation.Position position = 2;
inline bool VehiclePosition::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool VehiclePosition::has_position() const {
  return _internal_has_position();
}
inline void VehiclePosition::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::Position& VehiclePosition::_internal_position() const {
  const ::MontrealSubwayRealtimeLocation::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::Position&>(
      ::MontrealSubwayRealtimeLocation::_Position_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::Position& VehiclePosition::position() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehiclePosition.position)
  return _internal_position();
}
inline void VehiclePosition::unsafe_arena_set_allocated_position(
    ::MontrealSubwayRealtimeLocation::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.VehiclePosition.position)
}
inline ::MontrealSubwayRealtimeLocation::Position* VehiclePosition::release_position() {
  
  ::MontrealSubwayRealtimeLocation::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::Position* VehiclePosition::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.VehiclePosition.position)
  
  ::MontrealSubwayRealtimeLocation::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::Position* VehiclePosition::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::MontrealSubwayRealtimeLocation::Position* VehiclePosition::mutable_position() {
  ::MontrealSubwayRealtimeLocation::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.VehiclePosition.position)
  return _msg;
}
inline void VehiclePosition::set_allocated_position(::MontrealSubwayRealtimeLocation::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.VehiclePosition.position)
}

// uint32 current_stop_sequence = 3;
inline void VehiclePosition::clear_current_stop_sequence() {
  _impl_.current_stop_sequence_ = 0u;
}
inline uint32_t VehiclePosition::_internal_current_stop_sequence() const {
  return _impl_.current_stop_sequence_;
}
inline uint32_t VehiclePosition::current_stop_sequence() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehiclePosition.current_stop_sequence)
  return _internal_current_stop_sequence();
}
inline void VehiclePosition::_internal_set_current_stop_sequence(uint32_t value) {
  
  _impl_.current_stop_sequence_ = value;
}
inline void VehiclePosition::set_current_stop_sequence(uint32_t value) {
  _internal_set_current_stop_sequence(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.VehiclePosition.current_stop_sequence)
}

// string stop_id = 7;
inline void VehiclePosition::clear_stop_id() {
  _impl_.stop_id_.ClearToEmpty();
}
inline const std::string& VehiclePosition::stop_id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehiclePosition.stop_id)
  return _internal_stop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehiclePosition::set_stop_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stop_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.VehiclePosition.stop_id)
}
inline std::string* VehiclePosition::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.VehiclePosition.stop_id)
  return _s;
}
inline const std::string& VehiclePosition::_internal_stop_id() const {
  return _impl_.stop_id_.Get();
}
inline void VehiclePosition::_internal_set_stop_id(const std::string& value) {
  
  _impl_.stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehiclePosition::_internal_mutable_stop_id() {
  
  return _impl_.stop_id_.Mutable(GetArenaForAllocation());
}
inline std::string* VehiclePosition::release_stop_id() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.VehiclePosition.stop_id)
  return _impl_.stop_id_.Release();
}
inline void VehiclePosition::set_allocated_stop_id(std::string* stop_id) {
  if (stop_id != nullptr) {
    
  } else {
    
  }
  _impl_.stop_id_.SetAllocated(stop_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.VehiclePosition.stop_id)
}

// .MontrealSubwayRealtimeLocation.VehiclePosition.VehicleStopStatus current_status = 4;
inline void VehiclePosition::clear_current_status() {
  _impl_.current_status_ = 0;
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus VehiclePosition::_internal_current_status() const {
  return static_cast< ::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus >(_impl_.current_status_);
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus VehiclePosition::current_status() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehiclePosition.current_status)
  return _internal_current_status();
}
inline void VehiclePosition::_internal_set_current_status(::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus value) {
  
  _impl_.current_status_ = value;
}
inline void VehiclePosition::set_current_status(::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus value) {
  _internal_set_current_status(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.VehiclePosition.current_status)
}

// uint64 timestamp = 5;
inline void VehiclePosition::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t VehiclePosition::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t VehiclePosition::timestamp() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehiclePosition.timestamp)
  return _internal_timestamp();
}
inline void VehiclePosition::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void VehiclePosition::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.VehiclePosition.timestamp)
}

// .MontrealSubwayRealtimeLocation.VehiclePosition.CongestionLevel congestion_level = 6;
inline void VehiclePosition::clear_congestion_level() {
  _impl_.congestion_level_ = 0;
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel VehiclePosition::_internal_congestion_level() const {
  return static_cast< ::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel >(_impl_.congestion_level_);
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel VehiclePosition::congestion_level() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehiclePosition.congestion_level)
  return _internal_congestion_level();
}
inline void VehiclePosition::_internal_set_congestion_level(::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel value) {
  
  _impl_.congestion_level_ = value;
}
inline void VehiclePosition::set_congestion_level(::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel value) {
  _internal_set_congestion_level(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.VehiclePosition.congestion_level)
}

// .MontrealSubwayRealtimeLocation.VehiclePosition.OccupancyStatus occupancy_status = 9;
inline void VehiclePosition::clear_occupancy_status() {
  _impl_.occupancy_status_ = 0;
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus VehiclePosition::_internal_occupancy_status() const {
  return static_cast< ::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus >(_impl_.occupancy_status_);
}
inline ::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus VehiclePosition::occupancy_status() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehiclePosition.occupancy_status)
  return _internal_occupancy_status();
}
inline void VehiclePosition::_internal_set_occupancy_status(::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus value) {
  
  _impl_.occupancy_status_ = value;
}
inline void VehiclePosition::set_occupancy_status(::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus value) {
  _internal_set_occupancy_status(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.VehiclePosition.occupancy_status)
}

// -------------------------------------------------------------------

// Alert

// repeated .MontrealSubwayRealtimeLocation.TimeRange active_period = 1;
inline int Alert::_internal_active_period_size() const {
  return _impl_.active_period_.size();
}
inline int Alert::active_period_size() const {
  return _internal_active_period_size();
}
inline void Alert::clear_active_period() {
  _impl_.active_period_.Clear();
}
inline ::MontrealSubwayRealtimeLocation::TimeRange* Alert::mutable_active_period(int index) {
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.Alert.active_period)
  return _impl_.active_period_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TimeRange >*
Alert::mutable_active_period() {
  // @@protoc_insertion_point(field_mutable_list:MontrealSubwayRealtimeLocation.Alert.active_period)
  return &_impl_.active_period_;
}
inline const ::MontrealSubwayRealtimeLocation::TimeRange& Alert::_internal_active_period(int index) const {
  return _impl_.active_period_.Get(index);
}
inline const ::MontrealSubwayRealtimeLocation::TimeRange& Alert::active_period(int index) const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Alert.active_period)
  return _internal_active_period(index);
}
inline ::MontrealSubwayRealtimeLocation::TimeRange* Alert::_internal_add_active_period() {
  return _impl_.active_period_.Add();
}
inline ::MontrealSubwayRealtimeLocation::TimeRange* Alert::add_active_period() {
  ::MontrealSubwayRealtimeLocation::TimeRange* _add = _internal_add_active_period();
  // @@protoc_insertion_point(field_add:MontrealSubwayRealtimeLocation.Alert.active_period)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TimeRange >&
Alert::active_period() const {
  // @@protoc_insertion_point(field_list:MontrealSubwayRealtimeLocation.Alert.active_period)
  return _impl_.active_period_;
}

// repeated .MontrealSubwayRealtimeLocation.EntitySelector informed_entity = 5;
inline int Alert::_internal_informed_entity_size() const {
  return _impl_.informed_entity_.size();
}
inline int Alert::informed_entity_size() const {
  return _internal_informed_entity_size();
}
inline void Alert::clear_informed_entity() {
  _impl_.informed_entity_.Clear();
}
inline ::MontrealSubwayRealtimeLocation::EntitySelector* Alert::mutable_informed_entity(int index) {
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.Alert.informed_entity)
  return _impl_.informed_entity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::EntitySelector >*
Alert::mutable_informed_entity() {
  // @@protoc_insertion_point(field_mutable_list:MontrealSubwayRealtimeLocation.Alert.informed_entity)
  return &_impl_.informed_entity_;
}
inline const ::MontrealSubwayRealtimeLocation::EntitySelector& Alert::_internal_informed_entity(int index) const {
  return _impl_.informed_entity_.Get(index);
}
inline const ::MontrealSubwayRealtimeLocation::EntitySelector& Alert::informed_entity(int index) const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Alert.informed_entity)
  return _internal_informed_entity(index);
}
inline ::MontrealSubwayRealtimeLocation::EntitySelector* Alert::_internal_add_informed_entity() {
  return _impl_.informed_entity_.Add();
}
inline ::MontrealSubwayRealtimeLocation::EntitySelector* Alert::add_informed_entity() {
  ::MontrealSubwayRealtimeLocation::EntitySelector* _add = _internal_add_informed_entity();
  // @@protoc_insertion_point(field_add:MontrealSubwayRealtimeLocation.Alert.informed_entity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::EntitySelector >&
Alert::informed_entity() const {
  // @@protoc_insertion_point(field_list:MontrealSubwayRealtimeLocation.Alert.informed_entity)
  return _impl_.informed_entity_;
}

// .MontrealSubwayRealtimeLocation.Alert.Cause cause = 6;
inline void Alert::clear_cause() {
  _impl_.cause_ = 0;
}
inline ::MontrealSubwayRealtimeLocation::Alert_Cause Alert::_internal_cause() const {
  return static_cast< ::MontrealSubwayRealtimeLocation::Alert_Cause >(_impl_.cause_);
}
inline ::MontrealSubwayRealtimeLocation::Alert_Cause Alert::cause() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Alert.cause)
  return _internal_cause();
}
inline void Alert::_internal_set_cause(::MontrealSubwayRealtimeLocation::Alert_Cause value) {
  
  _impl_.cause_ = value;
}
inline void Alert::set_cause(::MontrealSubwayRealtimeLocation::Alert_Cause value) {
  _internal_set_cause(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.Alert.cause)
}

// .MontrealSubwayRealtimeLocation.Alert.Effect effect = 7;
inline void Alert::clear_effect() {
  _impl_.effect_ = 0;
}
inline ::MontrealSubwayRealtimeLocation::Alert_Effect Alert::_internal_effect() const {
  return static_cast< ::MontrealSubwayRealtimeLocation::Alert_Effect >(_impl_.effect_);
}
inline ::MontrealSubwayRealtimeLocation::Alert_Effect Alert::effect() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Alert.effect)
  return _internal_effect();
}
inline void Alert::_internal_set_effect(::MontrealSubwayRealtimeLocation::Alert_Effect value) {
  
  _impl_.effect_ = value;
}
inline void Alert::set_effect(::MontrealSubwayRealtimeLocation::Alert_Effect value) {
  _internal_set_effect(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.Alert.effect)
}

// .MontrealSubwayRealtimeLocation.TranslatedString url = 8;
inline bool Alert::_internal_has_url() const {
  return this != internal_default_instance() && _impl_.url_ != nullptr;
}
inline bool Alert::has_url() const {
  return _internal_has_url();
}
inline void Alert::clear_url() {
  if (GetArenaForAllocation() == nullptr && _impl_.url_ != nullptr) {
    delete _impl_.url_;
  }
  _impl_.url_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::TranslatedString& Alert::_internal_url() const {
  const ::MontrealSubwayRealtimeLocation::TranslatedString* p = _impl_.url_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::TranslatedString&>(
      ::MontrealSubwayRealtimeLocation::_TranslatedString_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::TranslatedString& Alert::url() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Alert.url)
  return _internal_url();
}
inline void Alert::unsafe_arena_set_allocated_url(
    ::MontrealSubwayRealtimeLocation::TranslatedString* url) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.url_);
  }
  _impl_.url_ = url;
  if (url) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.Alert.url)
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::release_url() {
  
  ::MontrealSubwayRealtimeLocation::TranslatedString* temp = _impl_.url_;
  _impl_.url_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.Alert.url)
  
  ::MontrealSubwayRealtimeLocation::TranslatedString* temp = _impl_.url_;
  _impl_.url_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::_internal_mutable_url() {
  
  if (_impl_.url_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TranslatedString>(GetArenaForAllocation());
    _impl_.url_ = p;
  }
  return _impl_.url_;
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::mutable_url() {
  ::MontrealSubwayRealtimeLocation::TranslatedString* _msg = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.Alert.url)
  return _msg;
}
inline void Alert::set_allocated_url(::MontrealSubwayRealtimeLocation::TranslatedString* url) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.url_;
  }
  if (url) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(url);
    if (message_arena != submessage_arena) {
      url = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, url, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.url_ = url;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.Alert.url)
}

// .MontrealSubwayRealtimeLocation.TranslatedString header_text = 10;
inline bool Alert::_internal_has_header_text() const {
  return this != internal_default_instance() && _impl_.header_text_ != nullptr;
}
inline bool Alert::has_header_text() const {
  return _internal_has_header_text();
}
inline void Alert::clear_header_text() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_text_ != nullptr) {
    delete _impl_.header_text_;
  }
  _impl_.header_text_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::TranslatedString& Alert::_internal_header_text() const {
  const ::MontrealSubwayRealtimeLocation::TranslatedString* p = _impl_.header_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::TranslatedString&>(
      ::MontrealSubwayRealtimeLocation::_TranslatedString_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::TranslatedString& Alert::header_text() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Alert.header_text)
  return _internal_header_text();
}
inline void Alert::unsafe_arena_set_allocated_header_text(
    ::MontrealSubwayRealtimeLocation::TranslatedString* header_text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_text_);
  }
  _impl_.header_text_ = header_text;
  if (header_text) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.Alert.header_text)
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::release_header_text() {
  
  ::MontrealSubwayRealtimeLocation::TranslatedString* temp = _impl_.header_text_;
  _impl_.header_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::unsafe_arena_release_header_text() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.Alert.header_text)
  
  ::MontrealSubwayRealtimeLocation::TranslatedString* temp = _impl_.header_text_;
  _impl_.header_text_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::_internal_mutable_header_text() {
  
  if (_impl_.header_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TranslatedString>(GetArenaForAllocation());
    _impl_.header_text_ = p;
  }
  return _impl_.header_text_;
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::mutable_header_text() {
  ::MontrealSubwayRealtimeLocation::TranslatedString* _msg = _internal_mutable_header_text();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.Alert.header_text)
  return _msg;
}
inline void Alert::set_allocated_header_text(::MontrealSubwayRealtimeLocation::TranslatedString* header_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_text_;
  }
  if (header_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header_text);
    if (message_arena != submessage_arena) {
      header_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_text, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_text_ = header_text;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.Alert.header_text)
}

// .MontrealSubwayRealtimeLocation.TranslatedString description_text = 11;
inline bool Alert::_internal_has_description_text() const {
  return this != internal_default_instance() && _impl_.description_text_ != nullptr;
}
inline bool Alert::has_description_text() const {
  return _internal_has_description_text();
}
inline void Alert::clear_description_text() {
  if (GetArenaForAllocation() == nullptr && _impl_.description_text_ != nullptr) {
    delete _impl_.description_text_;
  }
  _impl_.description_text_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::TranslatedString& Alert::_internal_description_text() const {
  const ::MontrealSubwayRealtimeLocation::TranslatedString* p = _impl_.description_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::TranslatedString&>(
      ::MontrealSubwayRealtimeLocation::_TranslatedString_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::TranslatedString& Alert::description_text() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Alert.description_text)
  return _internal_description_text();
}
inline void Alert::unsafe_arena_set_allocated_description_text(
    ::MontrealSubwayRealtimeLocation::TranslatedString* description_text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_text_);
  }
  _impl_.description_text_ = description_text;
  if (description_text) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.Alert.description_text)
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::release_description_text() {
  
  ::MontrealSubwayRealtimeLocation::TranslatedString* temp = _impl_.description_text_;
  _impl_.description_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::unsafe_arena_release_description_text() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.Alert.description_text)
  
  ::MontrealSubwayRealtimeLocation::TranslatedString* temp = _impl_.description_text_;
  _impl_.description_text_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::_internal_mutable_description_text() {
  
  if (_impl_.description_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TranslatedString>(GetArenaForAllocation());
    _impl_.description_text_ = p;
  }
  return _impl_.description_text_;
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString* Alert::mutable_description_text() {
  ::MontrealSubwayRealtimeLocation::TranslatedString* _msg = _internal_mutable_description_text();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.Alert.description_text)
  return _msg;
}
inline void Alert::set_allocated_description_text(::MontrealSubwayRealtimeLocation::TranslatedString* description_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.description_text_;
  }
  if (description_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(description_text);
    if (message_arena != submessage_arena) {
      description_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description_text, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.description_text_ = description_text;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.Alert.description_text)
}

// -------------------------------------------------------------------

// TimeRange

// uint64 start = 1;
inline void TimeRange::clear_start() {
  _impl_.start_ = uint64_t{0u};
}
inline uint64_t TimeRange::_internal_start() const {
  return _impl_.start_;
}
inline uint64_t TimeRange::start() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TimeRange.start)
  return _internal_start();
}
inline void TimeRange::_internal_set_start(uint64_t value) {
  
  _impl_.start_ = value;
}
inline void TimeRange::set_start(uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TimeRange.start)
}

// uint64 end = 2;
inline void TimeRange::clear_end() {
  _impl_.end_ = uint64_t{0u};
}
inline uint64_t TimeRange::_internal_end() const {
  return _impl_.end_;
}
inline uint64_t TimeRange::end() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TimeRange.end)
  return _internal_end();
}
inline void TimeRange::_internal_set_end(uint64_t value) {
  
  _impl_.end_ = value;
}
inline void TimeRange::set_end(uint64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TimeRange.end)
}

// -------------------------------------------------------------------

// Position

// float latitude = 1;
inline void Position::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline float Position::_internal_latitude() const {
  return _impl_.latitude_;
}
inline float Position::latitude() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Position.latitude)
  return _internal_latitude();
}
inline void Position::_internal_set_latitude(float value) {
  
  _impl_.latitude_ = value;
}
inline void Position::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.Position.latitude)
}

// float longitude = 2;
inline void Position::clear_longitude() {
  _impl_.longitude_ = 0;
}
inline float Position::_internal_longitude() const {
  return _impl_.longitude_;
}
inline float Position::longitude() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Position.longitude)
  return _internal_longitude();
}
inline void Position::_internal_set_longitude(float value) {
  
  _impl_.longitude_ = value;
}
inline void Position::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.Position.longitude)
}

// float bearing = 3;
inline void Position::clear_bearing() {
  _impl_.bearing_ = 0;
}
inline float Position::_internal_bearing() const {
  return _impl_.bearing_;
}
inline float Position::bearing() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Position.bearing)
  return _internal_bearing();
}
inline void Position::_internal_set_bearing(float value) {
  
  _impl_.bearing_ = value;
}
inline void Position::set_bearing(float value) {
  _internal_set_bearing(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.Position.bearing)
}

// double odometer = 4;
inline void Position::clear_odometer() {
  _impl_.odometer_ = 0;
}
inline double Position::_internal_odometer() const {
  return _impl_.odometer_;
}
inline double Position::odometer() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Position.odometer)
  return _internal_odometer();
}
inline void Position::_internal_set_odometer(double value) {
  
  _impl_.odometer_ = value;
}
inline void Position::set_odometer(double value) {
  _internal_set_odometer(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.Position.odometer)
}

// float speed = 5;
inline void Position::clear_speed() {
  _impl_.speed_ = 0;
}
inline float Position::_internal_speed() const {
  return _impl_.speed_;
}
inline float Position::speed() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.Position.speed)
  return _internal_speed();
}
inline void Position::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void Position::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.Position.speed)
}

// -------------------------------------------------------------------

// TripDescriptor

// string trip_id = 1;
inline void TripDescriptor::clear_trip_id() {
  _impl_.trip_id_.ClearToEmpty();
}
inline const std::string& TripDescriptor::trip_id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripDescriptor.trip_id)
  return _internal_trip_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripDescriptor::set_trip_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trip_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripDescriptor.trip_id)
}
inline std::string* TripDescriptor::mutable_trip_id() {
  std::string* _s = _internal_mutable_trip_id();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripDescriptor.trip_id)
  return _s;
}
inline const std::string& TripDescriptor::_internal_trip_id() const {
  return _impl_.trip_id_.Get();
}
inline void TripDescriptor::_internal_set_trip_id(const std::string& value) {
  
  _impl_.trip_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_trip_id() {
  
  return _impl_.trip_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_trip_id() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TripDescriptor.trip_id)
  return _impl_.trip_id_.Release();
}
inline void TripDescriptor::set_allocated_trip_id(std::string* trip_id) {
  if (trip_id != nullptr) {
    
  } else {
    
  }
  _impl_.trip_id_.SetAllocated(trip_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trip_id_.IsDefault()) {
    _impl_.trip_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TripDescriptor.trip_id)
}

// string route_id = 5;
inline void TripDescriptor::clear_route_id() {
  _impl_.route_id_.ClearToEmpty();
}
inline const std::string& TripDescriptor::route_id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripDescriptor.route_id)
  return _internal_route_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripDescriptor::set_route_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.route_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripDescriptor.route_id)
}
inline std::string* TripDescriptor::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripDescriptor.route_id)
  return _s;
}
inline const std::string& TripDescriptor::_internal_route_id() const {
  return _impl_.route_id_.Get();
}
inline void TripDescriptor::_internal_set_route_id(const std::string& value) {
  
  _impl_.route_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_route_id() {
  
  return _impl_.route_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_route_id() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TripDescriptor.route_id)
  return _impl_.route_id_.Release();
}
inline void TripDescriptor::set_allocated_route_id(std::string* route_id) {
  if (route_id != nullptr) {
    
  } else {
    
  }
  _impl_.route_id_.SetAllocated(route_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.route_id_.IsDefault()) {
    _impl_.route_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TripDescriptor.route_id)
}

// uint32 direction_id = 6;
inline void TripDescriptor::clear_direction_id() {
  _impl_.direction_id_ = 0u;
}
inline uint32_t TripDescriptor::_internal_direction_id() const {
  return _impl_.direction_id_;
}
inline uint32_t TripDescriptor::direction_id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripDescriptor.direction_id)
  return _internal_direction_id();
}
inline void TripDescriptor::_internal_set_direction_id(uint32_t value) {
  
  _impl_.direction_id_ = value;
}
inline void TripDescriptor::set_direction_id(uint32_t value) {
  _internal_set_direction_id(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripDescriptor.direction_id)
}

// string start_time = 2;
inline void TripDescriptor::clear_start_time() {
  _impl_.start_time_.ClearToEmpty();
}
inline const std::string& TripDescriptor::start_time() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripDescriptor.start_time)
  return _internal_start_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripDescriptor::set_start_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripDescriptor.start_time)
}
inline std::string* TripDescriptor::mutable_start_time() {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripDescriptor.start_time)
  return _s;
}
inline const std::string& TripDescriptor::_internal_start_time() const {
  return _impl_.start_time_.Get();
}
inline void TripDescriptor::_internal_set_start_time(const std::string& value) {
  
  _impl_.start_time_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_start_time() {
  
  return _impl_.start_time_.Mutable(GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_start_time() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TripDescriptor.start_time)
  return _impl_.start_time_.Release();
}
inline void TripDescriptor::set_allocated_start_time(std::string* start_time) {
  if (start_time != nullptr) {
    
  } else {
    
  }
  _impl_.start_time_.SetAllocated(start_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TripDescriptor.start_time)
}

// string start_date = 3;
inline void TripDescriptor::clear_start_date() {
  _impl_.start_date_.ClearToEmpty();
}
inline const std::string& TripDescriptor::start_date() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripDescriptor.start_date)
  return _internal_start_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripDescriptor::set_start_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripDescriptor.start_date)
}
inline std::string* TripDescriptor::mutable_start_date() {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TripDescriptor.start_date)
  return _s;
}
inline const std::string& TripDescriptor::_internal_start_date() const {
  return _impl_.start_date_.Get();
}
inline void TripDescriptor::_internal_set_start_date(const std::string& value) {
  
  _impl_.start_date_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_start_date() {
  
  return _impl_.start_date_.Mutable(GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_start_date() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TripDescriptor.start_date)
  return _impl_.start_date_.Release();
}
inline void TripDescriptor::set_allocated_start_date(std::string* start_date) {
  if (start_date != nullptr) {
    
  } else {
    
  }
  _impl_.start_date_.SetAllocated(start_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_date_.IsDefault()) {
    _impl_.start_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TripDescriptor.start_date)
}

// .MontrealSubwayRealtimeLocation.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
inline void TripDescriptor::clear_schedule_relationship() {
  _impl_.schedule_relationship_ = 0;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship TripDescriptor::_internal_schedule_relationship() const {
  return static_cast< ::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship >(_impl_.schedule_relationship_);
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship TripDescriptor::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TripDescriptor.schedule_relationship)
  return _internal_schedule_relationship();
}
inline void TripDescriptor::_internal_set_schedule_relationship(::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship value) {
  
  _impl_.schedule_relationship_ = value;
}
inline void TripDescriptor::set_schedule_relationship(::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship value) {
  _internal_set_schedule_relationship(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TripDescriptor.schedule_relationship)
}

// -------------------------------------------------------------------

// VehicleDescriptor

// string id = 1;
inline void VehicleDescriptor::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& VehicleDescriptor::id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehicleDescriptor.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehicleDescriptor::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.VehicleDescriptor.id)
}
inline std::string* VehicleDescriptor::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.VehicleDescriptor.id)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_id() const {
  return _impl_.id_.Get();
}
inline void VehicleDescriptor::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::release_id() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.VehicleDescriptor.id)
  return _impl_.id_.Release();
}
inline void VehicleDescriptor::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.VehicleDescriptor.id)
}

// string label = 2;
inline void VehicleDescriptor::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& VehicleDescriptor::label() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehicleDescriptor.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehicleDescriptor::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.VehicleDescriptor.label)
}
inline std::string* VehicleDescriptor::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.VehicleDescriptor.label)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_label() const {
  return _impl_.label_.Get();
}
inline void VehicleDescriptor::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::release_label() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.VehicleDescriptor.label)
  return _impl_.label_.Release();
}
inline void VehicleDescriptor::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.VehicleDescriptor.label)
}

// string license_plate = 3;
inline void VehicleDescriptor::clear_license_plate() {
  _impl_.license_plate_.ClearToEmpty();
}
inline const std::string& VehicleDescriptor::license_plate() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.VehicleDescriptor.license_plate)
  return _internal_license_plate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehicleDescriptor::set_license_plate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.license_plate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.VehicleDescriptor.license_plate)
}
inline std::string* VehicleDescriptor::mutable_license_plate() {
  std::string* _s = _internal_mutable_license_plate();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.VehicleDescriptor.license_plate)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_license_plate() const {
  return _impl_.license_plate_.Get();
}
inline void VehicleDescriptor::_internal_set_license_plate(const std::string& value) {
  
  _impl_.license_plate_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::_internal_mutable_license_plate() {
  
  return _impl_.license_plate_.Mutable(GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::release_license_plate() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.VehicleDescriptor.license_plate)
  return _impl_.license_plate_.Release();
}
inline void VehicleDescriptor::set_allocated_license_plate(std::string* license_plate) {
  if (license_plate != nullptr) {
    
  } else {
    
  }
  _impl_.license_plate_.SetAllocated(license_plate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_plate_.IsDefault()) {
    _impl_.license_plate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.VehicleDescriptor.license_plate)
}

// -------------------------------------------------------------------

// EntitySelector

// string agency_id = 1;
inline void EntitySelector::clear_agency_id() {
  _impl_.agency_id_.ClearToEmpty();
}
inline const std::string& EntitySelector::agency_id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.EntitySelector.agency_id)
  return _internal_agency_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntitySelector::set_agency_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agency_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.EntitySelector.agency_id)
}
inline std::string* EntitySelector::mutable_agency_id() {
  std::string* _s = _internal_mutable_agency_id();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.EntitySelector.agency_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_agency_id() const {
  return _impl_.agency_id_.Get();
}
inline void EntitySelector::_internal_set_agency_id(const std::string& value) {
  
  _impl_.agency_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntitySelector::_internal_mutable_agency_id() {
  
  return _impl_.agency_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EntitySelector::release_agency_id() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.EntitySelector.agency_id)
  return _impl_.agency_id_.Release();
}
inline void EntitySelector::set_allocated_agency_id(std::string* agency_id) {
  if (agency_id != nullptr) {
    
  } else {
    
  }
  _impl_.agency_id_.SetAllocated(agency_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agency_id_.IsDefault()) {
    _impl_.agency_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.EntitySelector.agency_id)
}

// string route_id = 2;
inline void EntitySelector::clear_route_id() {
  _impl_.route_id_.ClearToEmpty();
}
inline const std::string& EntitySelector::route_id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.EntitySelector.route_id)
  return _internal_route_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntitySelector::set_route_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.route_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.EntitySelector.route_id)
}
inline std::string* EntitySelector::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.EntitySelector.route_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_route_id() const {
  return _impl_.route_id_.Get();
}
inline void EntitySelector::_internal_set_route_id(const std::string& value) {
  
  _impl_.route_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntitySelector::_internal_mutable_route_id() {
  
  return _impl_.route_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EntitySelector::release_route_id() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.EntitySelector.route_id)
  return _impl_.route_id_.Release();
}
inline void EntitySelector::set_allocated_route_id(std::string* route_id) {
  if (route_id != nullptr) {
    
  } else {
    
  }
  _impl_.route_id_.SetAllocated(route_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.route_id_.IsDefault()) {
    _impl_.route_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.EntitySelector.route_id)
}

// int32 route_type = 3;
inline void EntitySelector::clear_route_type() {
  _impl_.route_type_ = 0;
}
inline int32_t EntitySelector::_internal_route_type() const {
  return _impl_.route_type_;
}
inline int32_t EntitySelector::route_type() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.EntitySelector.route_type)
  return _internal_route_type();
}
inline void EntitySelector::_internal_set_route_type(int32_t value) {
  
  _impl_.route_type_ = value;
}
inline void EntitySelector::set_route_type(int32_t value) {
  _internal_set_route_type(value);
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.EntitySelector.route_type)
}

// .MontrealSubwayRealtimeLocation.TripDescriptor trip = 4;
inline bool EntitySelector::_internal_has_trip() const {
  return this != internal_default_instance() && _impl_.trip_ != nullptr;
}
inline bool EntitySelector::has_trip() const {
  return _internal_has_trip();
}
inline void EntitySelector::clear_trip() {
  if (GetArenaForAllocation() == nullptr && _impl_.trip_ != nullptr) {
    delete _impl_.trip_;
  }
  _impl_.trip_ = nullptr;
}
inline const ::MontrealSubwayRealtimeLocation::TripDescriptor& EntitySelector::_internal_trip() const {
  const ::MontrealSubwayRealtimeLocation::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::MontrealSubwayRealtimeLocation::TripDescriptor&>(
      ::MontrealSubwayRealtimeLocation::_TripDescriptor_default_instance_);
}
inline const ::MontrealSubwayRealtimeLocation::TripDescriptor& EntitySelector::trip() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.EntitySelector.trip)
  return _internal_trip();
}
inline void EntitySelector::unsafe_arena_set_allocated_trip(
    ::MontrealSubwayRealtimeLocation::TripDescriptor* trip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = trip;
  if (trip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MontrealSubwayRealtimeLocation.EntitySelector.trip)
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* EntitySelector::release_trip() {
  
  ::MontrealSubwayRealtimeLocation::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* EntitySelector::unsafe_arena_release_trip() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.EntitySelector.trip)
  
  ::MontrealSubwayRealtimeLocation::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* EntitySelector::_internal_mutable_trip() {
  
  if (_impl_.trip_ == nullptr) {
    auto* p = CreateMaybeMessage<::MontrealSubwayRealtimeLocation::TripDescriptor>(GetArenaForAllocation());
    _impl_.trip_ = p;
  }
  return _impl_.trip_;
}
inline ::MontrealSubwayRealtimeLocation::TripDescriptor* EntitySelector::mutable_trip() {
  ::MontrealSubwayRealtimeLocation::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.EntitySelector.trip)
  return _msg;
}
inline void EntitySelector::set_allocated_trip(::MontrealSubwayRealtimeLocation::TripDescriptor* trip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_;
  }
  if (trip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip);
    if (message_arena != submessage_arena) {
      trip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trip_ = trip;
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.EntitySelector.trip)
}

// string stop_id = 5;
inline void EntitySelector::clear_stop_id() {
  _impl_.stop_id_.ClearToEmpty();
}
inline const std::string& EntitySelector::stop_id() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.EntitySelector.stop_id)
  return _internal_stop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntitySelector::set_stop_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stop_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.EntitySelector.stop_id)
}
inline std::string* EntitySelector::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.EntitySelector.stop_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_stop_id() const {
  return _impl_.stop_id_.Get();
}
inline void EntitySelector::_internal_set_stop_id(const std::string& value) {
  
  _impl_.stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntitySelector::_internal_mutable_stop_id() {
  
  return _impl_.stop_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EntitySelector::release_stop_id() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.EntitySelector.stop_id)
  return _impl_.stop_id_.Release();
}
inline void EntitySelector::set_allocated_stop_id(std::string* stop_id) {
  if (stop_id != nullptr) {
    
  } else {
    
  }
  _impl_.stop_id_.SetAllocated(stop_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.EntitySelector.stop_id)
}

// -------------------------------------------------------------------

// TranslatedString_Translation

// string text = 1;
inline void TranslatedString_Translation::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TranslatedString_Translation::text() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TranslatedString.Translation.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranslatedString_Translation::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TranslatedString.Translation.text)
}
inline std::string* TranslatedString_Translation::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TranslatedString.Translation.text)
  return _s;
}
inline const std::string& TranslatedString_Translation::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TranslatedString_Translation::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::release_text() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TranslatedString.Translation.text)
  return _impl_.text_.Release();
}
inline void TranslatedString_Translation::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TranslatedString.Translation.text)
}

// string language = 2;
inline void TranslatedString_Translation::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& TranslatedString_Translation::language() const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TranslatedString.Translation.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranslatedString_Translation::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MontrealSubwayRealtimeLocation.TranslatedString.Translation.language)
}
inline std::string* TranslatedString_Translation::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TranslatedString.Translation.language)
  return _s;
}
inline const std::string& TranslatedString_Translation::_internal_language() const {
  return _impl_.language_.Get();
}
inline void TranslatedString_Translation::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::release_language() {
  // @@protoc_insertion_point(field_release:MontrealSubwayRealtimeLocation.TranslatedString.Translation.language)
  return _impl_.language_.Release();
}
inline void TranslatedString_Translation::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MontrealSubwayRealtimeLocation.TranslatedString.Translation.language)
}

// -------------------------------------------------------------------

// TranslatedString

// repeated .MontrealSubwayRealtimeLocation.TranslatedString.Translation translation = 1;
inline int TranslatedString::_internal_translation_size() const {
  return _impl_.translation_.size();
}
inline int TranslatedString::translation_size() const {
  return _internal_translation_size();
}
inline void TranslatedString::clear_translation() {
  _impl_.translation_.Clear();
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString_Translation* TranslatedString::mutable_translation(int index) {
  // @@protoc_insertion_point(field_mutable:MontrealSubwayRealtimeLocation.TranslatedString.translation)
  return _impl_.translation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TranslatedString_Translation >*
TranslatedString::mutable_translation() {
  // @@protoc_insertion_point(field_mutable_list:MontrealSubwayRealtimeLocation.TranslatedString.translation)
  return &_impl_.translation_;
}
inline const ::MontrealSubwayRealtimeLocation::TranslatedString_Translation& TranslatedString::_internal_translation(int index) const {
  return _impl_.translation_.Get(index);
}
inline const ::MontrealSubwayRealtimeLocation::TranslatedString_Translation& TranslatedString::translation(int index) const {
  // @@protoc_insertion_point(field_get:MontrealSubwayRealtimeLocation.TranslatedString.translation)
  return _internal_translation(index);
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString_Translation* TranslatedString::_internal_add_translation() {
  return _impl_.translation_.Add();
}
inline ::MontrealSubwayRealtimeLocation::TranslatedString_Translation* TranslatedString::add_translation() {
  ::MontrealSubwayRealtimeLocation::TranslatedString_Translation* _add = _internal_add_translation();
  // @@protoc_insertion_point(field_add:MontrealSubwayRealtimeLocation.TranslatedString.translation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MontrealSubwayRealtimeLocation::TranslatedString_Translation >&
TranslatedString::translation() const {
  // @@protoc_insertion_point(field_list:MontrealSubwayRealtimeLocation.TranslatedString.translation)
  return _impl_.translation_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MontrealSubwayRealtimeLocation

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality>() {
  return ::MontrealSubwayRealtimeLocation::FeedHeader_Incrementality_descriptor();
}
template <> struct is_proto_enum< ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship>() {
  return ::MontrealSubwayRealtimeLocation::TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
}
template <> struct is_proto_enum< ::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus>() {
  return ::MontrealSubwayRealtimeLocation::VehiclePosition_VehicleStopStatus_descriptor();
}
template <> struct is_proto_enum< ::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel>() {
  return ::MontrealSubwayRealtimeLocation::VehiclePosition_CongestionLevel_descriptor();
}
template <> struct is_proto_enum< ::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus>() {
  return ::MontrealSubwayRealtimeLocation::VehiclePosition_OccupancyStatus_descriptor();
}
template <> struct is_proto_enum< ::MontrealSubwayRealtimeLocation::Alert_Cause> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MontrealSubwayRealtimeLocation::Alert_Cause>() {
  return ::MontrealSubwayRealtimeLocation::Alert_Cause_descriptor();
}
template <> struct is_proto_enum< ::MontrealSubwayRealtimeLocation::Alert_Effect> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MontrealSubwayRealtimeLocation::Alert_Effect>() {
  return ::MontrealSubwayRealtimeLocation::Alert_Effect_descriptor();
}
template <> struct is_proto_enum< ::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship>() {
  return ::MontrealSubwayRealtimeLocation::TripDescriptor_ScheduleRelationship_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gtfs_2drealtime_2eproto3
